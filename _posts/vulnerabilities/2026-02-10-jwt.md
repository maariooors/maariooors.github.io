---
title: üîë JWT
categories: [Vulnerabilidades]
tags: [jwt]
image: "/assets/img/jwt.svg"
description: "JSON Web Tokens attacks"
---

# üîë **JSON Web Token (JWT)**

Explicaci√≥n acerca de los JSON Web Tokens (JWT)

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/img/jwt.svg" width="300"/>
  <p style="font-style: italic; margin-top: 8x;">Copyright ¬© 2025 Okta.</p>
</div>


# üí°**¬øQu√© son los JWT?**

Un **JWT (JSON Web Token)** es un est√°ndar abierto usado para transmitir informaci√≥n de manera segura entre dos partes en formato JSON.  

Generalmente se utiliza en procesos de **autenticaci√≥n y autorizaci√≥n**. Por ejemplo, cuando un usuario inicia sesi√≥n, el servidor le entrega un token para que en cada petici√≥n posterior no tenga que volver a enviar usuario y contrase√±a.  

Un JWT es **autocontenido**, lo que significa que dentro del propio token ya viaja toda la informaci√≥n necesaria, firmada o cifrada, de modo que el receptor puede verificar su validez.  

Antes de analizar las vulnerabilidades que se pueden presentar al usar JWT, conviene entender su estructura y los algoritmos que se emplean para firmarlos o cifrarlos.  

---

## üèóÔ∏è**Estructura de un JWT**

La estructura de un JWT est√° compuesta por **tres partes**:  

- **Header**: contiene metadatos como el algoritmo de cifrado (`alg`), el identificador (`kid`), la clave p√∫blica para descifrar (`jwk`) o la posibilidad de obtener claves p√∫blicas v√°lidas desde una URL (`jku`).  

- **Payload**: incluye los llamados *claims*, que son b√°sicamente pares clave/valor. Al igual que el header, est√° codificado en **base64url** (similar a base64, pero sin los caracteres `+`, `/` y sin padding `=`). Aqu√≠ suele ir la informaci√≥n m√°s concreta sobre el token, como el usuario al que pertenece o los privilegios que posee.  

- **Firma**: se calcula a partir del header y el payload codificados en base64url, separados por un punto. Puede utilizar algoritmos de cifrado **sim√©trico o asim√©trico**.  

  - En **cifrado sim√©trico**, tanto el servidor que firma el token como el que lo valida comparten la misma clave secreta.  
  - En **cifrado asim√©trico**, el token se firma con una clave privada y se valida con la correspondiente clave p√∫blica.  

En ambos casos, la firma garantiza la integridad y autenticidad del JWT.  

---

## üîí**Cifrado sim√©trico**

En el **cifrado sim√©trico**:  

1. El usuario se autentica en el servidor.  
2. El servidor genera un JWT, lo firma usando su **clave privada o secreto** y lo devuelve al cliente (generalmente dentro de la cabecera `Cookie`).  
3. En cada petici√≥n posterior, el cliente env√≠a ese token.  
4. El servidor lo verifica usando la **misma clave secreta**.  
5. Si la verificaci√≥n es exitosa, el token se considera v√°lido y el usuario obtiene acceso a los recursos que le corresponden.  

---

## üîê**Cifrado asim√©trico**

En el **cifrado asim√©trico**:  

1. El usuario se autentica en el servidor.  
2. El servidor genera un JWT, lo firma con su **clave privada o secreto** y lo devuelve al cliente.  
3. En cada petici√≥n posterior, el cliente env√≠a ese token.  
4. El servidor lo verifica usando la **clave p√∫blica** correspondiente.  
5. Si la verificaci√≥n es correcta, el token se considera v√°lido y el usuario puede acceder a los recursos autorizados.  

---

Al igual que en otras secciones de este blog, utilizaremos los laboratorios de PortSwigger para llevar a cabo los ejemplos pr√°cticos.

---

# üß™**Laboratorios**

En caso de que quer√°is ver la resoluci√≥n directa de alg√∫n laboratorio, pod√©is utilizar el siguiente √≠ndice:

- [Lab 1](#lab-1): JWT authentication bypass via unverified signature
- [Lab 2](#lab-2): JWT authentication bypass via flawed signature verification
- [Lab 3](#lab-3): JWT authentication bypass via weak signing key
- [Lab 4](#lab-4): JWT authentication bypass via jwk header injection
- [Lab 5](#lab-5): JWT authentication bypass via jku header injection
- [Lab 6](#lab-6): JWT authentication bypass via kid header path traversal
- [Lab 7](#lab-7): JWT authentication bypass via algorithm confusion

Dado que los ataques sobre los **JWTs** no se clasifican estrictamente en grupos, sino m√°s bien en diferentes formas de enfoque, abordaremos la resoluci√≥n de los laboratorios de manera progresiva.

Para facilitar la resoluci√≥n de los laboratorios, es conveniente instalar la extensi√≥n de BurpSuite llamada `JWT Editor`.  

---

Al igual que en todos los laboratorios de esta secci√≥n, se nos proporcionar√°n las siguientes credenciales `wiener:peter`.  

Adem√°s, la forma de proceder ser√° siempre la misma: autenticarnos y recargar una petici√≥n a cualquier recurso de la p√°gina web para as√≠ visualizar nuestro JWT.

---

# Lab 1

**Omisi√≥n de la autenticaci√≥n JWT mediante firma no verificada**

En este laboratorio, al igual que en la mayor√≠a de los ejercicios anteriores, se nos solicita obtener un **JWT v√°lido** para el usuario **administrador** y utilizarlo para borrar al usuario **Carlos** del sistema.  

Se nos indica que **no se verifica la firma del JWT**. Por lo tanto, podemos interceptar la petici√≥n, abrir el **JWT Editor** y modificar el campo `sub`. En lugar de `wiener`, ponemos `administrator` y copiamos el nuevo JWT.  

A continuaci√≥n, pegamos este JWT en nuestras cookies en la p√°gina web. Como no se est√° verificando la firma de ninguna manera, podemos autenticarnos como el usuario **administrador** y proceder a borrar a Carlos.

---

# Lab 2

**Omisi√≥n de la autenticaci√≥n JWT mediante una verificaci√≥n de firma defectuosa**

Al igual que en los laboratorios anteriores, se nos solicita borrar al usuario **Carlos**.  

En esta ocasi√≥n, se nos indica que la verificaci√≥n de la **firma del JWT** no se realiza correctamente.  

En lugar de seguir el procedimiento del laboratorio anterior, podemos modificar el **algoritmo (`alg`)** a `none` y copiar todo el JWT, excepto la parte de la firma, es decir, solo el **header** y el **payload**.  

De esta manera, es posible generar un JWT v√°lido para el usuario **administrador**.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/jwt/jwt-3.png" width="1000"/>
</div>

En este caso, el m√©todo funciona correctamente, ya que la validaci√≥n del JWT no es completa.

---

# Lab 3

**Omisi√≥n de la autenticaci√≥n JWT mediante una clave de firma d√©bil**

Al igual que en los laboratorios anteriores, se nos solicita borrar al usuario **Carlos**.  

En este caso, se nos indica que la **clave secreta** es d√©bil. Esto representa un problema, ya que al ser un cifrado **sim√©trico**, si conseguimos adivinar la clave, podemos firmar cualquier JWT y ser√° considerado v√°lido, dado que la verificaci√≥n se realiza con la misma clave.  

Si tomamos un JWT y lo analizamos con **Hashcat**, que permite realizar ataques de fuerza bruta, obtenemos que el secreto es `secret1`.

A partir de este punto, podemos utilizar BurpSuite para generar una **nueva firma** con este secreto para el usuario **administrador**. Como la firma se crea y verifica con la misma clave, el JWT ser√° considerado v√°lido.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/jwt/jwt-2.png" width="1000"/>
</div>

---

# Lab 4

**Omisi√≥n de la autenticaci√≥n JWT mediante la inyecci√≥n de encabezados jwk**

Al igual que en los laboratorios anteriores, se nos solicita borrar al usuario **Carlos**.

En este caso estamos ante una **clave asim√©trica**, es decir, que el token se ha firmado con un **secreto (clave privada)** pero se valida con una **clave p√∫blica**.

Si probamos todo lo aprendido en los laboratorios anteriores, veremos que nada funciona, por lo que hay que pensar en un enfoque distinto. Dentro de los pares **clave/valor** que se pueden incluir en el header de un JWT, existe el campo `jwk`, en el cual se especifica la **clave p√∫blica** con la que se ha cifrado el token.  

Si esto no se valida correctamente, puede ser un problema, ya que nosotros podr√≠amos:

- Crear un JWT con nuestra **clave privada** para el usuario administrador.
- Incluir en el propio JWT la **clave p√∫blica** correspondiente dentro de `jwk`.
- Si no est√° controlado, el servidor usar√° esa clave para validar el JWT.

Justamente esto es lo que se utiliza para resolver el laboratorio.  
Lo que tenemos que hacer en **BurpSuite** es:

1. Crear una nueva **clave asim√©trica** para el usuario administrador.  
2. Copiar la **clave p√∫blica** dentro del header del JWT.

---

# Lab 5

**Omisi√≥n de la autenticaci√≥n JWT mediante la inyecci√≥n de encabezados jku**

Al igual que en los laboratorios anteriores, se nos solicita borrar al usuario **Carlos**.

La forma de enfocar este laboratorio es exactamente la misma que en el caso anterior: firmar el JWT con nuestro **secreto** y pasarle al servidor la **clave p√∫blica** para que lo valide.  

No obstante, esta vez la cabecera `jwk` est√° siendo **sanitizada** y no es vulnerable. Sin embargo, no solo podemos escribir la clave p√∫blica en la cabecera `jwk`, sino que tambi√©n podemos alojarla en un **servidor externo** y referenciarla mediante la cabecera `jku`.

Esto es lo que usaremos para resolver el laboratorio:  
- Utilizar el **exploit server de PortSwigger** para almacenar la **clave p√∫blica**.  
- A√±adir la cabecera `jku` para hacer referencia a ese exploit server de la siguiente manera:  

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/jwt/jwt-1.png" width="1000"/>
</div>

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/jwt/jwt-4.png" width="1000"/>
</div>

---

# Lab 6

**Omisi√≥n de la autenticaci√≥n JWT mediante path traversal del par√°metro kid**

Al igual que en los laboratorios anteriores, se nos solicita borrar al usuario **Carlos**.

En este caso, tenemos un **JWT firmado con clave sim√©trica**, es decir, que se cifra y valida con el **mismo secreto**.  

Aqu√≠ entra en juego la cabecera `kid`, que se utiliza para especificar un identificador del token. Este identificador normalmente sirve para buscar la clave asociada dentro de un directorio donde se almacenan todas las claves disponibles para validar los tokens existentes.  

El inconveniente aparece cuando el valor de `kid` no est√° **bien sanitizado**, ya que se puede usar para realizar **directory path traversal** y apuntar a rutas que no deber√≠an ser accesibles.  

Esto es justo lo que ocurre en el laboratorio:
- El servidor usa el valor de `kid` para buscar una clave dentro de un directorio.  
- Al no estar sanitizado, se vuelve vulnerable a **path traversal**.  
- Sin embargo, simplemente recorrer directorios hacia atr√°s har√≠a que el servidor intentase usar otro archivo como clave para validar el token, lo cual no ser√≠a efectivo, a menos que se use un archivo como `/dev/null`.

El archivo `/dev/null` contiene un **byte nulo**. Esto resulta √∫til porque:  
- Podemos firmar nuestro certificado **sim√©trico** con un byte nulo (`AA==` en Base64).  
- Luego, mediante **path traversal** en el `kid`, apuntamos a `/dev/null`.  
- De esta forma, al validar el token, coinciden tanto el secreto usado como el valor devuelto por el archivo.

Todo esto ser ver√≠a de la siguiente manera:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/jwt/jwt-5.png" width="1000"/>
</div>

---

# Lab 7

**Omisi√≥n de la autenticaci√≥n JWT mediante confusi√≥n de algoritmos**

Al igual que en los laboratorios anteriores, se nos solicita borrar al usuario **Carlos**.


En este caso, se nos indica que existe una **ruta expuesta en la URL** donde se muestra la **clave p√∫blica** usada para validar los JWTs.  

Buscando en Internet, se observa que la ruta por defecto para los JWT suele ser `jwks.json`.

Si hacemos un `curl` a esa ruta, podemos ver la clave p√∫blica:
```bash
curl -s "https://0a94009a03948ade870fe20100da0047.web-security-academy.net/jwks.json" | jq
{
  "keys": [
    {
      "kty": "RSA",
      "e": "AQAB",
      "use": "sig",
      "kid": "bbf1c06f-7cd2-4c8d-9e47-d13249ba50aa",
      "alg": "RS256",
      "n": "tL3Ez9m_4LvsZFjnJU-2zAl8tbFf0vZpwoRZSBHbs9PCv9kve2PfQAjZmutgIR2ZjSR3Yr0tOLsFC9hkZsfN5ThseZCydlkWZcUTYB_wDDI3c7XBzTbxDqFv27rfJkXtk0aZkQjMKff7qs25304sz3H5DLOKGBBPsUbT4qpK1HaDD368Vh3pHcq-niqaQsOd-leO0PPOPdtHwDnnkIpLhTH2kBb2egFeyEfh0NWwxeFpj55XVVh4zrnbHuY___oqqhDzLYe81agdW4330ZQKTqs8poI8yhsv0LgHquHx0UVxrXcnictX2yjMZI99peHWlDsenDtviMG1wItiKdlwQQ"
    }
  ]
}
```

En este caso, el algoritmo es asim√©trico, por lo que la clave expuesta no permite firmar un nuevo JWT y hacerlo v√°lido, sin embargo, se pueden probar otras t√©cnicas.

La condici√≥n que nos va a permitir resolver este laboratorio es que un servidor no est√© bien configurado y use la misma clave para validar algoritmos asim√©tricos y sim√©tricos. Esto significa que si recibe un token asim√©trico lo validar√° con la clave p√∫blica, pero si recibe uno sim√©trico lo validar√° con la clave privada, que en este caso ser√° la misma. En otras palabras, si el servidor utiliza la misma clave para validar asim√©trico y sim√©trico, la clave que hemos obtenido es la p√∫blica de un algoritmo asim√©trico, pero tambi√©n la privada de un sim√©trico.

Por ello, lo que podemos hacer es ir a **BurpSuite**, crear una nueva clave asim√©trica **RS256** y en la parte de clave p√∫blica pegar la del servidor de la siguiente manera:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/jwt/jwt-6.png" width="1000"/>
</div>

A continuaci√≥n, nos copiaremos la clave p√∫blica en formato **PEM** de esa nueva clave **RS256** (es decir, la clave p√∫blica del servidor), la codificaremos en **Base64** y crearemos una nueva clave **sim√©trica**, donde en el valor de **K** (key/secreto) pondremos la clave p√∫blica en formato PEM codificada en Base64.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/jwt/jwt-7.png" width="1000"/>
</div>

Con esto, lo que estamos indicando es que en nuestra clave sim√©trica el secreto es la **clave p√∫blica del servidor**, y como el servidor va a usar esta misma clave para validarlo debido a su mala configuraci√≥n, hemos creado un **JWT v√°lido**.

Ahora solo queda ir al JWT original, cambiar el campo `alg` a **HS256** y firmarlo con nuestra clave sim√©trica.
