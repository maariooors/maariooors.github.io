---
title:  üï∏Ô∏è CSRF
categories: [Vulnerabilidades]
tags: [csrf]
image: "/assets/img/csrf.png"
description: "Cross-Site Request Forgery attack"
---

# üï∏Ô∏è **Cross-Site Request Forgery (CSRF)**

Explicaci√≥n acerca de Cross-Site Request Forgery (CSRF)

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/img/csrf.png" width="300"/>
  <p style="font-style: italic; margin-top: 8x;">Copyright ¬© 2010-2025 Freepik Company S.L.</p>
</div>

# üï∏Ô∏è **Cross-Site Request Forgery (CSRF)**

Explicaci√≥n acerca de Cross-Site Request Forgery (CSRF)

# üí°**¬øQu√© es el CSRF?**

**Cross-Site Request Forgery (CSRF)** es una vulnerabilidad web que permite a un atacante forzar a un usuario autenticado en una aplicaci√≥n a ejecutar acciones no deseadas sin su consentimiento.

Para que un ataque CSRF sea efectivo, generalmente deben cumplirse ciertos requisitos:

1. La v√≠ctima debe estar **autenticada** en la aplicaci√≥n.  
2. El servidor debe enviar autom√°ticamente las **cookies** de sesi√≥n del usuario.  
3. Debe existir en el servidor alg√∫n **vector vulnerable** que permita ejecutar la acci√≥n no deseada.

En esta secci√≥n del blog utilizaremos los laboratorios de PortSwigger para explicar, paso a paso, los distintos escenarios en los que puede producirse CSRF.

---

# üß™**Laboratorios**

En caso de que quer√°is ver la resoluci√≥n directa de alg√∫n laboratorio, pod√©is utilizar el siguiente √≠ndice:

- [Lab 1](#lab-1): CSRF vulnerability with no defenses
- [Lab 2](#lab-2): CSRF where token validation depends on request method
- [Lab 3](#lab-3): CSRF where token validation depends on token being present
- [Lab 4](#lab-4): CSRF where token is not tied to user session
- [Lab 5](#lab-5): CSRF where token is tied to non-session cookie
- [Lab 6](#lab-6): CSRF where token is duplicated in cookie
- [Lab 7](#lab-7): SameSite Lax bypass via method override
- [Lab 8](#lab-8): SameSite Strict bypass via client-side redirect
- [Lab 9](#lab-9): SameSite Strict bypass via sibling domain
- [Lab 10](#lab-10): SameSite Lax bypass via cookie refresh
- [Lab 11](#lab-11): CSRF where Referer validation depends on header being present
- [Lab 12](#lab-12): CSRF with broken Referer validation

---

Dado que los ataques **CSRF** no se clasifican estrictamente en grupos, sino m√°s bien en diferentes formas de enfoque, abordaremos la resoluci√≥n de los laboratorios de manera progresiva.

---

## Lab 1

**CSRF sin defensas**

En este laboratorio, al igual que en muchos otros, se nos proporcionan unas credenciales, que en este caso son `wiener:peter`. Si iniciamos sesi√≥n con estas credenciales, observaremos que existe una opci√≥n para **cambiar el correo**. Al hacer clic en esta opci√≥n, se nos mostrar√° el siguiente formulario:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/csrf/csrf-form.png" width="1000"/>
</div>

Podemos intentar cambiar el correo a, por ejemplo `test@test.com` y, para observar lo que ocurre internamente, podemos capturar la petici√≥n mediante **Burp Suite**.  
Si modificamos el m√©todo de la petici√≥n a `GET`, veremos que no funciona, ya que el servidor indica que el m√©todo no es v√°lido.  

No obstante, al no existir ning√∫n token de protecci√≥n, podemos dirigirnos a nuestro **exploit server** para comprobar si un script b√°sico funciona en esta ocasi√≥n.  

En nuestro servidor atacante podemos insertar el siguiente c√≥digo HTML:
```html
<form action="https://0ae8008204767ac580040386003e00b3.web-security-academy.net/my-account/change-email" method="POST">
    <input type="hidden" name="email" value="hacked@hacked.com">
</form>

<script>document.forms[0].submit()</script>
```

Al enviar el enlace al usuario v√≠ctima, veremos que completamos el laboratorio con √©xito, logrando cambiar su correo electr√≥nico.  

Esto es posible porque la v√≠ctima estaba **autenticada** en la p√°gina web y no exist√≠a ning√∫n mecanismo de protecci√≥n contra este tipo de ataques.

## Lab 2

**CSRF donde la validaci√≥n del token depende del m√©todo de solicitud**

Una vez m√°s, se nos proporcionan las credenciales `wiener:peter` y volvemos a tener el mismo formulario para el cambio de correo.  

En esta ocasi√≥n, si interceptamos la petici√≥n, observamos lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/csrf/csrf-1.png" width="1000"/>
</div>

Como se puede apreciar, ahora contamos con un **token CSRF**, el cual se asigna al realizar el cambio y previene, en cierta medida, que esta secci√≥n pueda ser vulnerada.  

Si eliminamos este **token CSRF**, la petici√≥n no se procesa porque falta el token. Sin embargo, si intentamos tramitar la petici√≥n mediante `GET`, observamos que, a pesar de la ausencia del token, el cambio se efect√∫a.  

Con este conocimiento, podemos dirigirnos al **exploit server** y colocar el siguiente c√≥digo:
```html
<form action="https://0a72007c0411d4d1d32bf0ec009c00cc.web-security-academy.net/my-account/change-email" method="GET">
    <input type="hidden" name="email" value="hacked@hacked.com">
</form>

<script>document.forms[0].submit()</script>
```

De esta manera, se fuerza el env√≠o de la petici√≥n mediante **GET**, evitando as√≠ la validaci√≥n del **token CSRF**.

## Lab 3

**CSRF en el que la validaci√≥n del token depende de que este est√© presente**

Una vez m√°s, se nos proporcionan las credenciales `wiener:peter` y volvemos a tener el mismo formulario para el cambio de correo. 

En este caso, si interceptamos la petici√≥n, podemos observar nuevamente que existe un **token CSRF**.  
Si lo modificamos, la petici√≥n no se procesa porque el token es inv√°lido. Sin embargo, si lo eliminamos por completo, el cambio se efect√∫a. Esto ocurre porque internamente el sistema solo verifica si el token es v√°lido, pero no exige que est√© presente.  

Teniendo esto en cuenta, podemos regresar al **exploit server** e introducir el siguiente c√≥digo:
```html
<form action="https://0a52009d0333f46380751c0200bd0087.web-security-academy.net/my-account/change-email" method="POST">
    <input type="hidden" name="email" value="hacked@hacked.com">
</form>

<script>document.forms[0].submit()</script>
```

## Lab 4

**CSRF donde el token no est√° vinculado a la sesi√≥n del usuario**

En este laboratorio tenemos **dos usuarios** distintos, cada uno con sus credenciales correspondientes: `wiener:peter` y `carlos:montoya`
Abrimos dos pesta√±as y, tras interceptar una petici√≥n de cambio de correo para cada usuario, comprobamos lo siguiente:

- Cada usuario recibe un **token CSRF diferente**.  
- Si intercambiamos los tokens (es decir, usamos el de *wiener* en *carlos* y viceversa), las solicitudes se procesan sin inconvenientes.  
Esto significa que el servidor √∫nicamente valida si el token es correcto, **pero no lo asocia a una sesi√≥n concreta**.  

Adem√°s, al intentar reutilizar un token CSRF de una petici√≥n anterior, vemos que ya no funciona.  
Esto indica que los **tokens son de un solo uso**.  

Con esto en mente, podemos interceptar una nueva petici√≥n, **guardar el token** y **dropear la solicitud**, de forma que ese token queda generado pero no consumido.  

Una vez hecho esto, nos dirigimos al **exploit server** y preparamos un formulario muy similar a los de laboratorios anteriores, donde se env√≠e una solicitud POST a la ruta de cambio de correo, incluyendo el token CSRF v√°lido pero a√∫n no utilizado:
```html
<form action="https://0a00008c04782191809c037400dc00d0.web-security-academy.net/my-account/change-email" method="POST">
    <input type="hidden" name="email" value="hacked@hacked.com">
    <input type="hidden" name="csrf" value="XtRS4slyxGhUfgzJARaUtqcSyLOko7iJ">
</form>

<script>document.forms[0].submit()</script>
```

De esta manera, conseguimos explotar la validaci√≥n deficiente del token CSRF, completando el laboratorio.

## Lab 5

**CSRF donde el token est√° vinculado a una cookie que no es de sesi√≥n**

Al igual que en el laboratorio anterior, volvemos a contar con los mismos usuarios (`wiener` y `carlos`).  
Si interceptamos una petici√≥n para cada uno de ellos, vemos que tenemos el **CSRF token** y una **cookie** que va ligada a dicho token.  

Si probamos a poner el CSRF token de *wiener* a *carlos* o viceversa, vemos que no nos deja, ya que este va ligado a la cookie y esta no la podemos modificar mediante un formulario.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/csrf/csrf-2.png" width="1000"/>
</div>

Si indagamos un poco por la p√°gina, encontramos el campo de b√∫squeda que ya hemos visto en otros laboratorios.  

Por ejemplo, si realizamos una b√∫squeda con la palabra `test` y volvemos a interceptar la petici√≥n, observamos que se nos a√±ade una nueva cookie llamada **`lastsearch`**.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/csrf/csrf-3.png" width="1000"/>
</div>

Esa cookie proviene directamente del par√°metro `?search` de la URL, por lo que podemos intentar jugar con √©l.  

Si probamos a introducir, por ejemplo, un `;` para salir del contexto del token actual y modificar las cookies, vemos que no es posible.  

No obstante, podemos intentar realizar un salto de l√≠nea utilizando el retorno de carro (`\r`) y el propio salto de l√≠nea (`\n`) para as√≠ insertar nuevos tokens.  

Podemos probar lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/csrf/csrf-4.png" width="1000"/>
</div>

Donde, en `csrfkey`, introducimos un token v√°lido de alguno de los usuarios y configuramos `SameSite=None` para evitar problemas al operar entre p√°ginas diferentes.  

Si probamos todo esto en una petici√≥n propia, vemos que funciona correctamente.  

Por lo tanto, podemos ir al **exploit server** y forzar una b√∫squeda en el campo `search`, de manera que se modifique la cookie `csrfkey`, y posteriormente ejecutar la petici√≥n a `change-email`.  

Todo esto lo llevamos a cabo con el siguiente c√≥digo:
```html
<form action="https://0ada000a031653d28052037900210040.web-security-academy.net/my-account/change-email" method="POST">
    <input type="hidden" name="email" value="csrf@afsefasefasef.com">
    <input type="hidden" name="csrf" value="2nykYqEnxSMVqMnCxi8f2KGUMAiLHLgQ">
</form>

<img src="https://0ada000a031653d28052037900210040.web-security-academy.net/?search=hola%0d%0aSet-Cookie:%20csrfKey=zD1ppGOxNEP2lJqfqossVqUWclEqXxvR%3b%20SameSite=None" onerror="document.forms[0].submit();">
```

Con esto, el laboratorio estar√≠a completo.  

No obstante, vamos a explicar un poco mejor qu√© est√° pasando aqu√≠. Para que aparezca el campo de **√∫ltima b√∫squeda** en la secci√≥n de cookies ‚Äîel cual es el que usamos para cambiar el token CSRF‚Äî primero debemos realizar una b√∫squeda.  

Aqu√≠ entra en juego la **imagen**, que intenta cargar un recurso desde una URL. Sin embargo, esta URL en realidad corresponde a una petici√≥n al campo de b√∫squeda junto con el *payload malicioso* para modificar la cookie `csrfkey`.  

Como obviamente esa imagen no va a cargarse correctamente, en caso de error hemos definido que se env√≠e el formulario que est√° arriba, el cual se encarga de realizar el **cambio de email** con el token CSRF asociado a la cookie que acabamos de modificar.


## Lab 6

**CSRF donde el token se duplica en la cookie**

El proceso para resolver este laboratorio es exactamente el mismo que en el [Lab 5](#lab-5), solo que en esta ocasi√≥n la **cookie `csrfkey`** y el **token CSRF** son id√©nticos.  

Adem√°s, no necesitan ser v√°lidos; √∫nicamente deben coincidir entre s√≠.  

Por lo tanto, el laboratorio se resuelve utilizando el mismo c√≥digo que se mostr√≥ anteriormente:
```html
<form action="https://0a9800dd0404852f80a0030b004300e6.web-security-academy.net/my-account/change-email" method="POST">
    <input type="hidden" name="email" value="pwned@pwned.com">
    <input type="hidden" name="csrf" value="fake">
</form>

<img src="https://0a9800dd0404852f80a0030b004300e6.web-security-academy.net/?search=hola%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None" onerror="document.forms[0].submit();">
```

## Lab 7

**Omisi√≥n de SameSite Lax mediante la anulaci√≥n del m√©todo**

En este laboratorio, volvemos a contar √∫nicamente con las credenciales de `wiener:peter`.  

Para resolverlo, seguimos el mismo procedimiento de siempre: interceptamos la petici√≥n de cambio de correo y probamos a modificar el m√©todo de env√≠o a `GET` para comprobar si funciona.  

Una vez m√°s, esto no es suficiente.  

Sin embargo, se incorpora un m√©todo de **sobreescritura**, en el que podemos insertar `&_method=POST` al final de la URL, tal y como se aprecia en la siguiente imagen:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/csrf/csrf-5.png" width="1000"/>
</div>

De esta manera, conseguimos enga√±ar al servidor y realizar la petici√≥n utilizando `GET`.  

Una vez comprendido este funcionamiento, nos dirigimos al **exploit server** y realizamos lo siguiente:
```html
<script>
    document.location = "https://0a6000a10360807fdd3a506a00530037.web-security-academy.net/my-account/change-email?email=pwned@pwnedt&_method=POST";
</script>
```

## Lab 8

**Omisi√≥n de SameSite Strict mediante redireccionamiento del lado del cliente**

Una vez m√°s, se nos proporcionan las credenciales `wiener:peter` y volvemos a contar con el mismo formulario para el cambio de correo.  

Si interceptamos la petici√≥n, observamos que esta vez **no se env√≠a el token CSRF** que normalmente se incluye en las solicitudes `POST`.  

Esto nos indica que aparentemente **no existe protecci√≥n CSRF** en este caso.  

Por lo tanto, podemos dirigirnos al **exploit server** y probar el caso base:
```html
<form action="https://0a9500ef033b464d80c703e7007f00d9.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="pwned@pwned.com">
</form>

<script>document.forms[0].submit()</script>
```

Si probamos a hacer clic en **ver exploit** para comprobar si funciona con nuestra propia sesi√≥n, vemos que **no funciona** y que nos redirige directamente al **panel de login**.  

Al interceptar todo el tr√°fico de esa consulta, observamos que cuando llegamos al servidor de la v√≠ctima **no se nos ha asignado ninguna cookie de sesi√≥n**. Por este motivo, el servidor nos dirige autom√°ticamente al login para iniciar sesi√≥n.  

Intentamos usar el m√©todo `GET`, y aunque la solicitud es permitida por esta v√≠a, nos encontramos con el mismo problema de redirecci√≥n al login.  

Sin embargo, si en lugar de forzar un cambio de correo electr√≥nico, forzamos una **visita a la p√°gina**, por ejemplo:
```html
<script>
    document.location = "https://0a9500ef033b464d80c703e7007f00d9.web-security-academy.net/post/4";
</script>
```

Vemos que ahora s√≠ se nos asigna una **cookie de sesi√≥n**.  

Adem√°s, nos damos cuenta de que en los posts existe un **campo de formulario**.  
Si lo llenamos con cualquier valor y hacemos clic en enviar, observamos que, una vez publicado el comentario, el sistema nos redirige autom√°ticamente al blog donde hemos hecho la publicaci√≥n.  

Al inspeccionar un poco m√°s, descubrimos que esta redirecci√≥n est√° controlada por un archivo JavaScript ubicado en `/resources/js/commentConfirmationRedirect.js`


Al revisar el contenido del archivo, encontramos el siguiente c√≥digo:
```javascript
redirectOnConfirmation = (blogPath) => {
    setTimeout(() => {
        const url = new URL(window.location);
        const postId = url.searchParams.get("postId");
        window.location = blogPath + '/' + postId;
    }, 3000);
}
```

Como podemos observar, el script est√° tomando el **n√∫mero de post** a partir de un par√°metro y lo concatena a la URL para redirigirnos all√≠.  

No obstante, ese par√°metro es **controlable por nosotros**, por lo que podemos probar valores como `?postId=../` para verificar si es posible realizar un **path traversal**.

Si forzamos una b√∫squeda hacia ese post, vemos que terminamos en la **p√°gina inicial** de la web.  

Esto nos permite combinar varias cosas:  
- Al realizar una b√∫squeda, se nos asigna una **cookie de sesi√≥n**.  
- La aplicaci√≥n permite cambios de email mediante `GET`.  

Por lo tanto, podemos forzar una b√∫squeda hacia un post usando **path traversal**, conseguir que la sesi√≥n no se cierre, y directamente en la URL acceder a la secci√≥n de **cambio de email**.  

Todo esto quedar√≠a de la siguiente manera:
```javascript
location="https://0a9500ef033b464d80c703e7007f00d9.web-security-academy.net/post/comment/confirmation?postId=../my-account/change-email?email=pene%40pwned.com%26submit=1";
```

## Lab 9

**Omisi√≥n de SameSite Strict a trav√©s de un dominio hermano**

## Lab 10

**Omisi√≥n de SameSite Lax mediante la actualizaci√≥n de cookies**

## Lab 11

**CSRF donde la validaci√≥n del Referer depende de la presencia del encabezado**

Una vez m√°s, se nos proporcionan las credenciales `wiener:peter` y volvemos a contar con el mismo formulario para el cambio de correo.  

Si interceptamos una petici√≥n de cambio de email, podemos observar el **header `Referer`**, que ser√° el elemento con el que tendremos que jugar para resolver este laboratorio.  

El **header HTTP `Referer`** es un campo que el navegador a√±ade autom√°ticamente en las peticiones para indicar la URL de la p√°gina desde la que se origin√≥ la solicitud. Esto ayuda al servidor a determinar si la petici√≥n proviene de la misma web o de un sitio externo.  

En este caso, si eliminamos el header y enviamos la petici√≥n, veremos que en lugar de dar un error, la solicitud se procesa correctamente. Esto ocurre porque el servidor √∫nicamente valida si el valor del origen es correcto, pero **no comprueba si el header est√° presente**.  

A ra√≠z de esto, podemos ir al **exploit server** y enviar el siguiente payload:
```html
<html>
    <head>
        <meta name="referrer"content="no-referrer">
    </head>

    <form action="https://0a2600fa03c988d580f4adf9002300c0.web-security-academy.net/my-account/change-email" method="POST">
        <input type="hidden" name="email" value="pwned@pwned.com">
    </form>

    <script>
        document.forms[0].submit()
    </script>
</html>
```

## Lab 12

**CSRF con validaci√≥n Referer defectuosa**

Una vez m√°s, se nos proporcionan las credenciales `wiener:peter` y volvemos a contar con el mismo formulario para el cambio de correo.

Al igual que en el [Lab 11](#lab-11), debemos jugar con el **header `Referer`** para resolver el laboratorio.  

No obstante, en esta ocasi√≥n, si interceptamos la petici√≥n y tratamos de eliminar completamente el header, la solicitud no se env√≠a.  
Sin embargo, si a√±adimos o eliminamos algunos caracteres, la petici√≥n sigue pasando.  

Esto nos hace intuir que el servidor realiza alg√∫n tipo de validaci√≥n del **origen**, pero no de manera estricta; parece que permite variaciones, posiblemente para **subdominios** u otras modificaciones menores en la URL.
Podemos irnos al **exploit server** y, en lugar de hospedar el c√≥digo malicioso bajo la ruta `/exploit` como hemos hecho siempre, podemos, por ejemplo, usar como ruta el **mismo nombre de la URL del servidor v√≠ctima**.  

De esta forma, cuando se realiza la validaci√≥n, el servidor revisa si coinciden ciertos caracteres. Al enviar la petici√≥n desde `exploit-server/dominio-v√≠ctima`, en el header `Referer` aparecer√° nuestro servidor malicioso, pero tambi√©n incluir√° todo el **dominio real de la v√≠ctima**, lo que permite que la validaci√≥n pase correctamente.  

Adem√°s, es importante a√±adir el siguiente header en nuestra p√°gina maliciosa `Referrer-Policy: unsafe-url`.

Esto asegura que el `Referer` env√≠e **toda la ruta** y no solo la URL base.

Todo esto se ver√≠a de la siguiente manera:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/csrf/csrf-6.png" width="1000"/>
</div>