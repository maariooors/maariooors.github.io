---
title: üí• Buffer Overflow
categories: [Vulnerabilidades]
description: "Buffer Overflow exploitation"
---

# üí• **Buffer Overflow**

Explicaci√≥n acerca de los Buffers Overflows

<div style="text-align: center;">
  <svg fill="#ffffffff" width="600px" height="400px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M 19.59375 2.84375 L 17.96875 3.96875 L 23.5625 12.1875 L 25.1875 11.0625 Z M 15.375 6.53125 L 14.0625 8.03125 L 21.5625 14.53125 L 22.875 13.03125 Z M 12.375 10.90625 L 11.46875 12.6875 L 20.3125 17.1875 L 21.21875 15.40625 Z M 10.65625 15.4375 L 10.21875 17.375 L 19.875 19.65625 L 20.3125 17.71875 Z M 6 18 L 6 29 L 24 29 L 24 18 L 22 18 L 22 27 L 8 27 L 8 18 Z M 10.09375 19.6875 L 9.96875 21.6875 L 19.875 22.25 L 20 20.25 Z M 10 23 L 10 25 L 19.9375 25 L 19.9375 23 Z"/></svg>
  <p style="font-style: italic; margin-top: 8x;">¬© 2016-25. All rights reserved by Zasya Solutions.</p>
</div>

# **¬øQu√© es un Buffer Overflow?**

Un **buffer overflow** (desbordamiento de buffer) es una vulnerabilidad de seguridad que ocurre cuando un programa escribe m√°s datos de los que un **buffer** puede almacenar, sobrescribiendo memoria adyacente.

## **Qu√© es un Buffer**

Un **buffer** es un √°rea contigua de memoria reservada para almacenar datos (como un array o un `char buf[16]`).  

Cuando se excede su capacidad, los datos "extra" sobrescriben otras partes de la memoria, que pueden ser:

- Variables locales vecinas  
- Saved frame pointer (RBP/EBP)  
- Return address  
- Otras estructuras de control  

---

Para entender c√≥mo funciona un **buffer overflow** a la perfecci√≥n y saber c√≥mo explotarlo, conviene primero comprender a bajo nivel c√≥mo funciona la memoria de un proceso.

---

# **Esquema de memoria de un proceso**

La memoria de un proceso se compone de 5 o 6 segmentos (dependiendo de la fuente). Cada uno tiene un prop√≥sito espec√≠fico y se encuentra organizado de manera concreta. Estos segmentos son:

- [**Code (.text)**](#segmento-code-text): Aqu√≠ se encuentran las instrucciones en lenguaje m√°quina.  
- [**Data (.data)**](#segmento-data-y-read-only-data-data--rodata): Aqu√≠ se almacenan las variables globales.  
- [**Read-only data (.rodata)**](#segmento-data-y-read-only-data-data--rodata): Aqu√≠ se encuentran las constantes globales y cadenas de texto.  
- [**BSS (.bss)**](#segmento-bss-bss): Contiene variables globales sin valor expl√≠cito o inicializadas a 0.  
- [**Heap**](#segmento-heap): Memoria din√°mica solicitada en tiempo de ejecuci√≥n.  
- [**Stack (pila)**](#segmento-stack-pila): Aqu√≠ se gestionan las llamadas a funciones.  

Los dos √∫ltimos segmentos (**Heap** y **Stack**) se encuentran contiguos. Debido a esto, y a que su tama√±o var√≠a durante la ejecuci√≥n del programa, es posible que ocurran desbordamientos de buffer si alg√∫n buffer excede los l√≠mites establecidos.  

Un enfoque m√°s visual puede ser el siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/bo/process-memory-schema.png" width="500"/>
</div>

En funci√≥n del gr√°fico que se consulte, los segmentos **.data** y **.rodata** pueden aparecer unificados en **.data**.  

Adem√°s, es importante tener en cuenta que el **Stack** crece hacia direcciones bajas de memoria, mientras que el **Heap** crece hacia posiciones altas de memoria.

---

## **Segmento Code (.text)**

El segmento **.text** contiene las instrucciones en lenguaje m√°quina que la CPU ejecuta directamente. En este segmento se almacenan todas las funciones compiladas del programa.  

Normalmente tiene permisos de **lectura y ejecuci√≥n (r-x)**, pero no permite escritura, lo que protege el c√≥digo frente a modificaciones accidentales o ataques de tipo **code injection**.

Un ejemplo de c√≥digo simple en C que se almacena en el segmento **.text** es el siguiente:
```c
int suma(int a, int b) {
    return a + b;
}
```

En este caso, la funci√≥n realiza una suma de dos par√°metros, pero en la secci√≥n **.text** solo se almacenan las instrucciones m√°quina necesarias para realizar esa suma en registros. No se reserva espacio para `int a` o `int b`, ya que esto se gestionar√° en el momento en que se llame a la funci√≥n, utilizando el **stack (pila)**.

---

## **Segmento Data y Read-Only Data (.data / .rodata)**

El segmento **.data** contiene las variables **globales y est√°ticas** que han sido inicializadas en el momento de la compilaci√≥n. Estas variables existen durante toda la ejecuci√≥n del programa y, a diferencia del c√≥digo, este segmento tiene permisos de **lectura y escritura (rw-)**, lo que permite modificar sus valores en tiempo de ejecuci√≥n.  

Por otro lado, el segmento **.rodata (Read-Only Data)** almacena **constantes y cadenas literales globales** del programa, y tiene permisos de **solo lectura (r--)**, protegiendo los datos frente a modificaciones accidentales o ataques que intenten sobrescribir informaci√≥n constante.

Un ejemplo de c√≥digo C correspondiente a este segmento ser√≠a:
```c
int contador = 5;   // va en .data (inicializado)
const char *msg = "Hola"; // "Hola" va en .rodata; el puntero en .data

int main() { // Almacenado en .text
    ...
}
```

---

## **Segmento BSS (.bss)**

El segmento **.bss (Block Starting Symbol)** almacena las **variables globales y est√°ticas** que no tienen un valor expl√≠cito en el c√≥digo o que est√°n inicializadas a cero. Aunque no ocupan espacio en el archivo ejecutable, el sistema operativo reserva memoria para ellas en tiempo de ejecuci√≥n, y sus valores se inicializan autom√°ticamente a cero.  

Este segmento permite que las variables existan durante toda la ejecuci√≥n del programa y tiene permisos de **lectura y escritura (rw-)**, al igual que **.data**.

Un ejemplo de c√≥digo C correspondiente a este segmento ser√≠a:
```c
static int buffer[1024]; // si no se inicializa, est√° en .bss y comienza en 0
```

---

## **Segmento Heap**

El **heap** es el segmento de memoria reservado para la **asignaci√≥n din√°mica en tiempo de ejecuci√≥n**, mediante funciones como `malloc`, `calloc`, `realloc` en C o `new` en C++.  

A diferencia de las variables locales, la memoria en el **heap** persiste hasta que se libera expl√≠citamente con `free` o `delete`, o hasta que finaliza el proceso. El heap crece hacia **direcciones m√°s altas en memoria** y permite almacenar datos cuyo tama√±o o duraci√≥n no puede determinarse en tiempo de compilaci√≥n.

Un ejemplo de c√≥digo C correspondiente a este segmento ser√≠a:
```c
char *p = malloc(100); // p apunta a un bloque de 100 bytes en el heap
```

**Consideraciones al trabajar con el Heap**

- No importa si el `malloc` se realiza dentro o fuera de una funci√≥n; la memoria reservada siempre se aloja en el **heap**.  
- Lo que cambia es **d√≥nde se almacena el puntero**. Si el puntero `p` es una variable local dentro de una funci√≥n, vivir√° en el **stack** y desaparecer√° cuando la funci√≥n termine.  
- Esto genera un problema: si antes de finalizar la funci√≥n el puntero `p` no se libera, el bloque de memoria seguir√° presente en el heap pero **no ser√° accesible**, provocando una fuga de memoria.  

Un ejemplo gr√°fico ser√≠a:
```c
void f() {
    char *p = malloc(100); // bloque en heap
} // aqu√≠ p desaparece porque estaba en el stack,
// pero los 100 bytes siguen en el heap ‚Üí memoria perdida
```

Si el puntero `p` es **global o est√°tico**, seguir√° existiendo durante toda la ejecuci√≥n del programa y se podr√° usar para acceder al bloque en el **heap** desde cualquier parte.

---

## **Segmento Stack (Pila)**

La pila es una estructura de memoria que funciona seg√∫n el principio **LIFO** (*Last In, First Out*), es decir, lo √∫ltimo que se a√±ade es lo primero que se retira. Cada vez que se llama a una funci√≥n, el sistema crea un **[frame de pila](#frame-de-pila-y-registros)** espec√≠fico para esa funci√≥n.  

Este frame almacena:  
- Los **par√°metros** que se le pasaron a la funci√≥n.  
- Las **variables locales** de la funci√≥n.  
- La **direcci√≥n de retorno**, que indica a qu√© instrucci√≥n debe volver la CPU cuando la funci√≥n termine.  

Por ejemplo, en la funci√≥n:

```c
void f(int x) {
    char buf[16];  // variable local
}
```

El buffer `buf` se encuentra dentro del **frame de pila** y existe √∫nicamente mientras la funci√≥n se ejecuta. Cuando la funci√≥n termina, el frame se destruye y la memoria de `buf` queda libre para el siguiente frame. La pila crece hacia **direcciones de memoria m√°s bajas**.

Para manejar la pila, la CPU utiliza **[registros espec√≠ficos](#frame-de-pila-y-registros)**:  
- `RSP`/`ESP` apunta siempre al **tope de la pila**.  
- `RBP`/`EBP` apunta al **inicio del frame** de la funci√≥n actual, sirviendo como ancla para acceder a par√°metros y variables locales.  

La **direcci√≥n de retorno** almacenada en cada frame es utilizada por la instrucci√≥n `ret` para que la CPU pueda continuar correctamente la ejecuci√≥n despu√©s de que la funci√≥n termine.

### Frame de pila y registros

Para entender bien el funcionamiento del **stack** y d√≥nde pueden ocurrir problemas, es necesario explicar claramente qu√© son y c√≥mo funcionan los **frames de pila**, as√≠ como c√≥mo funcionan los registros `ESP/RSP` y `EBP/RBP`, ya que ambos conceptos est√°n estrechamente enlazados.

Un **frame de pila** se crea cuando se llama a una funci√≥n. Cuando esto ocurre, se genera en el stack una estructura parecida a la siguiente:
```text
Direcciones altas
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
| Par√°metro 3 (si hay)      | ‚Üê [rbp+24]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
| Par√°metro 2 (si hay)      | ‚Üê [rbp+16]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
| Par√°metro 1 (si hay)      | ‚Üê [rbp+8]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
| Return address            | ‚Üê guardado por 'call'
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
| Saved RBP (frame anterior)| ‚Üê [rbp]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
| Variable local 1          | ‚Üê [rbp-8]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
| Variable local 2 / buffer | ‚Üê [rbp-16]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
| Variable local 3          | ‚Üê [rbp-24]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Tope actual de la pila ‚Üí RSP
Direcciones bajas
```

Como se aprecia, primero se deja espacio para los **par√°metros de la funci√≥n**, luego se almacena la **direcci√≥n de retorno** de la funci√≥n, es decir, la direcci√≥n a donde debe volver la CPU una vez que la funci√≥n termine:
```c
int main() {
    int x = f(); // -> Se llama a f(), cuando termine tiene que volver aqu√≠ la funci√≥n
    printf("%d\n", x);
}
```

Despu√©s, se guarda el registro `RBP` (arquitectura x86_64) o `EBP` (arquitectura x86) del frame anterior. Este registro se encarga de almacenar la **direcci√≥n de memoria del inicio del frame de pila**, es decir, la posici√≥n a partir de los par√°metros y la direcci√≥n de retorno. Esto se debe a que se considera que la funci√≥n comienza a ejecutar instrucciones una vez que se han guardado los par√°metros y la direcci√≥n a donde volver al finalizar.  

Al guardarse en el frame de pila el valor del `RBP/EBP` anterior, tambi√©n se actualiza el **registro** `RBP/EBP` con esa direcci√≥n de memoria para poder operar con ella. Despu√©s de esto, simplemente se guardan las **variables locales** de la funci√≥n y se restaura el registro `RSP/ESP` para apuntar al final del frame de pila anterior.

**Registros RBP/EBP**

Es conveniente explicar en detalle el concepto de **RBP/EBP** y el de **Saved RBP**.  

Cuando hay un frame de pila y se llama a otra funci√≥n, se genera un **nuevo frame de pila encima del anterior** (en realidad, "debajo", porque la pila crece hacia abajo).  

Al generarse este nuevo frame:  
- Se guardan los **par√°metros**, la **direcci√≥n de retorno** y la **posici√≥n de memoria** del registro `RBP/EBP` anterior para no perderlo.  
- Al mismo tiempo, se **actualiza el registro `RBP/EBP`** con la posici√≥n de memoria donde se acaba de guardar el valor del `RBP/EBP` anterior.  

Esto permite tener siempre localizada, como valor, la posici√≥n de memoria donde se encuentra el **inicio del frame de pila** de la funci√≥n anterior. Por ello, cuando este frame de pila se borre, el registro `RBP/EBP` se sobreescribir√° con el valor que hab√≠a en la direcci√≥n de memoria a la que apuntaba, ya que all√≠ estaba almacenada otra direcci√≥n de memoria.

**Registros RSP/ESP (Frame de pila)**

Una vez explicado el funcionamiento de los registros `RBP/EBP`, es necesario entender c√≥mo funcionan los registros `RSP` (arquitectura x86_64) y `ESP` (arquitectura x86).  

Para que se cree un frame de pila encima de otro, **una funci√≥n debe llamar a otra funci√≥n**. Por ejemplo, si la funci√≥n **B** llama a la funci√≥n **C**:  
- En el stack ya existe un **frame de pila para B** donde se guarda todo lo que la funci√≥n necesita.  
- Al llamar a la funci√≥n C con unos par√°metros, vamos a suponer por sencillez que se guardan en el frame de pila de C (esto no es siempre cierto ya que en funci√≥n de como se pasen los par√°metros cambia, o si estamos ante una arquitectura x86_64).  

Esto es importante para visualizar c√≥mo se mueve el registro `RSP/ESP` cuando el frame de C desaparece:  

- Cuando la funci√≥n C termina, el registro `RSP/ESP` se mueve a donde estaba `RBP/EBP`.  
- Se carga en el registro `RBP/EBP` el valor que hab√≠a en memoria.  
- El registro `EIP` apunta a `ESP` y se carga en √©l la direcci√≥n de memoria de `ret` (`ESP + 4`).  
- Al ejecutar la instrucci√≥n `pop EIP`, esta direcci√≥n de memoria se libera, moviendo el registro `RSP/ESP` a ese espacio libre.  
- El resultado es que queda justo **por debajo de los argumentos de C**, y ya es el propio programa el que se encarga de sumarle a `EIP` el espacio que ocupaban los argumentos.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/bo/registers.png" width="800"/>
</div>

**NOTA:**  

Cabe destacar que esta explicaci√≥n y el diagrama presentado corresponden a **arquitectura x86** y a un **paso de par√°metros por valor**, para simplificar la comprensi√≥n.  

En el caso de **arquitectura x86_64**:  
- Los primeros 6 par√°metros se pasan por **registro**.  
- Existe un **alineamiento de pila a 16 bytes**.  
- Hay una **`red zone`** de 128 bytes por debajo del `RSP`.  

A pesar de estas diferencias, los conceptos explicados hasta ahora son **m√°s que suficientes** para comprender el funcionamiento general de la pila y los frames de funci√≥n.

---