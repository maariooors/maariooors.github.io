---
title: 游닇 SSTI
categories: [Vulnerabilidades]
tags: [ssti]
image: "/assets/img/ssti.png"
description: "Sever-Side Request Forgery attack"
---

# 游닇 **Sever-Side Template Injection (SSTI)**

Explicaci칩n acerca de Server-Side Template Injection (SSTI)

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/img/ssti.png" width="300"/>
  <p style="font-style: italic; margin-top: 8x;">Copyright 춸 2010-2025 Freepik Company S.L.</p>
</div>

# 游눠**쯈u칠 es un SSTI?**

Un **Server-Side Template Injection (SSTI)** es una vulnerabilidad que ocurre cuando una aplicaci칩n web permite que la entrada de un usuario se inserte directamente en una plantilla procesada en el servidor sin ser correctamente sanitizada.  

Dado que los motores de plantillas no solo sustituyen valores, sino que tambi칠n pueden interpretar expresiones y ejecutar l칩gica, un atacante puede aprovechar esta situaci칩n para inyectar su propio c칩digo dentro de la plantilla.  

Para comprender mejor este concepto, es importante explicar qu칠 es una plantilla y qu칠 es un motor de plantillas.  

---

# 游늯**쯈u칠 es una plantilla?**

Una plantilla es un archivo que define la estructura base de un documento (por ejemplo, HTML) e incluye espacios reservados o marcadores donde se insertan datos din치micos.  

Su funci칩n principal es separar la l칩gica del programa de la presentaci칩n. En lugar de generar manualmente todo el contenido con c칩digo de backend, el desarrollador define el dise침o en la plantilla y deja "huecos" que se rellenan autom치ticamente con informaci칩n en **tiempo de ejecuci칩n**.  

Esto permite reutilizar el mismo dise침o para mostrar datos distintos, manteniendo un c칩digo m치s limpio, organizado y f치cil de mantener.  

---

# 丘뙖잺**쯈u칠 es un motor de plantillas?**

Un motor de plantillas es la herramienta o componente de un framework que se encarga de procesar las plantillas y transformarlas en un resultado final, normalmente en formato HTML, que posteriormente se env칤a al navegador del usuario.  
Una vez que hemos comprendido estos tres conceptos, podemos pasar a la explicaci칩n de c칩mo se explota esta vulnerabilidad.

---

Al igual que en otras secciones de este blog, utilizaremos los laboratorios de PortSwigger para llevar a cabo los ejemplos pr치cticos.

---

# 游빍**Laboratorios**

En caso de que quer치is ver la resoluci칩n directa de alg칰n laboratorio, pod칠is utilizar el siguiente 칤ndice:

- [Lab 1](#lab-1): Basic server-side template injection
- [Lab 2](#lab-2): Basic server-side template injection (code context)
- [Lab 3](#lab-3): Server-side template injection using documentation
- [Lab 4](#lab-4): Server-side template injection in an unknown language with a documented exploit
- [Lab 5](#lab-5): Server-side template injection with information disclosure via user-supplied objects
- [Lab 6](#lab-6): Server-side template injection in a sandboxed environment
- [Lab 7](#lab-7): Server-side template injection with a custom exploit

---

Dado que los ataques de **SSTI** no se clasifican estrictamente en grupos, sino m치s bien en diferentes formas de enfoque, abordaremos la resoluci칩n de los laboratorios de manera progresiva.

Adem치s, debido al tipo de ataque que es, nos apoyaremos en gran medida en la p치gina de [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings), de donde obtendremos las l칤neas de c칩digo necesarias para la explotaci칩n.

**IMPORTANTE**:  

Dado que este blog est치 escrito utilizando un motor de plantillas, los ejemplos de payloads mostrados no se visualizar치n como texto literal en la web, sino que se interpretan por el motor.  

Por este motivo, se recomienda **no tomar los payloads de forma literal** y consultar la p치gina de [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) para obtener los ejemplos correctos.  

En muchos casos he tenido que omitir ciertos caracteres como los corchetes, ya que, de lo contrario, el motor de plantillas interpretar칤a el contenido en lugar de mostrarlo tal cual.

---

# Lab 1

**SSTI b치sica**

Para resolver este laboratorio, al igual que en la mayor칤a de los de esta secci칩n, se nos solicita borrar un archivo ubicado en la ruta `/home/carlos/morale.txt`.  

En este laboratorio se indica que el motor de plantillas es **ERB**, que pertenece al lenguaje **Ruby**.  

Al interactuar con la p치gina, se observa que en el primer post, al hacer clic, no se abre ning칰n contenido sino que aparece un mensaje dentro del HTML indicando que el producto no est치 disponible. Al revisar la URL, notamos que ese mismo mensaje se encuentra dentro de un par치metro:  
```bash
https://0ac6007e03e439a680a5212c00b00063.web-security-academy.net/?message=Unfortunately this product is out of stock
```

Si modificamos ese mensaje con cualquier otro texto y recargamos la p치gina, el contenido que hemos insertado se interpreta y aparece dentro de la estructura HTML. Esto sugiere que se est치 procesando directamente el input del usuario.  

Consultando [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) y buscando payloads para ERB de Ruby, se observa que la inyecci칩n b치sica puede probarse con `<%= 7 * 7 %>`.


Si colocamos esto en el par치metro `message` de la siguiente manera:  
```bash
https://0ac6007e03e439a680a5212c00b00063.web-security-academy.net/?message=<%= 7 * 7 %>
```

y recargamos, veremos que en el HTML aparece `49`, confirmando que el input se est치 interpretando.  

A partir de aqu칤, podemos llevar a cabo un **RCE (Remote Code Execution)** para borrar el archivo deseado utilizando el siguiente payload:  
```bash
<%=(rm /home/carlos/morale.txt)%>
```

---

# Lab 2

**SSTI b치sica con error**

Para resolver este laboratorio, nuevamente se nos solicita borrar un archivo ubicado en la ruta `/home/carlos/morale.txt`.  

Adem치s, se nos proporcionan las credenciales del usuario: `wiener:peter`.  

Si iniciamos sesi칩n con este usuario y accedemos a su perfil, observamos lo siguiente:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/ssti/ssti-1.png" width="1000"/>
</div>

Al desplegar el campo de `nombre preferido`, se observan m칰ltiples opciones.  

Esto significa que, al publicar un post, el nombre que se mostrar치 a los dem치s usuarios ser치 el valor que hayamos seleccionado en este campo.  

Si interceptamos una petici칩n al cambiar el nombre preferido, se observa que se tramita de la siguiente manera:

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/ssti/ssti-2.png" width="1000"/>
</div>

Si, por ejemplo, probamos en el par치metro `blog-post-author-display` algo como `#$%^`, estamos saliendo del contexto original de la plantilla, ya que la mayor칤a del c칩digo que se interpreta en las plantillas se encuentra entre llaves. Con estos caracteres especiales, cerramos el contexto anterior y abrimos uno nuevo.  

Al visitar un post donde hayamos publicado un comentario, se genera un error y, por el mensaje de salida, podemos identificar que el motor de plantillas utilizado es **Tornado de Python**.  

Consultando [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) y buscando payloads para **Tornado**, el payload b치sico de prueba es `7*7`.

Si introducimos esto en el par치metro `blog-post-author-display` y visitamos un post con nuestro comentario, veremos que nuestro nombre se reemplaza por `49`, confirmando que el input se interpreta correctamente.  

A partir de aqu칤, podemos realizar un **RCE (Remote Code Execution)** utilizando el siguiente payload para borrar el archivo `/home/carlos/morale.txt`:
```html
%import os% os.system('rm /home/carlos/morale.txt')
```

---

# Lab 3

**SSTI usando documentaci칩n**

Para resolver este laboratorio, nuevamente se nos solicita borrar un archivo ubicado en la ruta `/home/carlos/morale.txt`.  

En este laboratorio, en lugar de recibir las credenciales habituales, se nos proporcionan las de un usuario denominado *content manager* `content-manager:C0nt3ntM4n4g3r`.

Al iniciar sesi칩n con estas credenciales y acceder a un post, observamos que tenemos la capacidad de editarlo.  

Dentro del editor, aparecen partes del texto que utilizan plantillas, por ejemplo `${product.stock}`.

Si reemplazamos ese valor por caracteres aleatorios para forzar un error y aplicamos los cambios, se genera un mensaje de error que revela cu치l es el motor de plantillas utilizado.  

En este caso se trata de **Java Freemarker**.  

Por lo tanto, como en los laboratorios anteriores, acudimos a [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) para buscar el payload correspondiente que nos permita realizar un **RCE (Remote Code Execution)**.

---

# Lab 4

**SSTI en un motor de plantillas poco com칰n**

Para resolver este laboratorio, nuevamente se nos solicita borrar un archivo ubicado en la ruta `/home/carlos/morale.txt` y se nos vuelven a dar las credenciales `content-manager:C0nt3ntM4n4g3r`.

De manera similar al laboratorio anterior, al editar un post y forzar un error, identificamos que esta vez el motor de plantillas utilizado es **Handlebars**.  

Una vez m치s, consultamos [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) para localizar el payload de **RCE (Remote Code Execution)** correspondiente.

---

# Lab 5

**SSTI con filtrado de informaci칩n**

En este laboratorio, en lugar de solicitarnos borrar el archivo `/home/carlos/morale.txt`, el objetivo es obtener la **secret key** de la aplicaci칩n.  

Al igual que en los dos laboratorios anteriores, se nos proporcionan las credenciales `content-manager:C0nt3ntM4n4g3r`.

Tras forzar un error en la edici칩n de un post, identificamos que el motor de plantillas utilizado es **Django (Python)**.  

En este caso, al consultar [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings), no encontramos directamente un payload para listar la clave privada. Sin embargo, investigando un poco m치s en internet, descubrimos que es posible obtenerla mediante `settings.SECRET_KEY`.

---

# Lab 6

**SSTI con para romper el sandbox**

Para resolver este laboratorio, se nos solicita leer un archivo ubicado en la ruta `/home/carlos/my_password.txt`.  

Una vez m치s, se nos proporcionan las credenciales `content-manager:C0nt3ntM4n4g3r`.

Tras forzar un error en la edici칩n de un post, identificamos que el motor de plantillas utilizado es **Freemarker (Java)**.  

El payload de **RCE** que permite leer el archivo es el siguiente `${product.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve('/home/carlos/my_password.txt').toURL().openStream().readAllBytes()?join(" ")}`

Este payload devuelve el contenido del archivo en formato decimal `97 117 99 113 51 104 101 115 122 48 54 97 110 119 104 119 51 52 98 115`.

Debemos convertir esta secuencia de valores a **ASCII**, obteniendo as칤 la contrase침a `aucq3hesz06anwhw34bs`

---

# Lab 7

Para resolver este laboratorio, se nos proporcionan las credenciales de `wiener:peter` y se nos pide que borremos el archivo ubicado en la ruta `/home/carlos/.ssh/id_rsa`.

Una vez m치s, tenemos disponible la opci칩n de cambiar la forma en la que queremos que se muestre nuestro nombre cuando comentamos en un post. Si interceptamos la petici칩n en **BurpSuite** y probamos con la inyecci칩n b치sica `7*7`, vemos que aparece `49` al lado de nuestro nombre. Si forzamos un error poniendo caracteres especiales, nos damos cuenta de que el motor de plantillas utilizado es **Twig** de PHP. No obstante, si probamos todas las opciones de RCE listadas en [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings), ninguna funciona. Por ello, debemos buscar otro enfoque para cumplir el objetivo.

En esta ocasi칩n, tambi칠n se nos otorga la posibilidad de subir un avatar para mostrar al lado de nuestro nombre. Si subimos una imagen e interceptamos la petici칩n, podemos experimentar con ella:

- Si cambiamos el contenido por `test`, el sistema devuelve un error en un archivo llamado `User.php`.

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/ssti/ssti-3.png" width="1000"/>
</div>

- Si eliminamos el **content-type**, aparece el error `User->setAvatar('/tmp/avatar.jpg', '')`

Este error filtra una funci칩n interna del servidor encargada de cambiar el avatar. Adem치s, muestra c칩mo es el paso de par치metros esperado: primero la ruta y despu칠s el tipo de archivo. En el ejemplo, aparece vac칤o porque eliminamos el content-type.

Cuando cambiamos el nombre que se muestra en un comentario, la petici칩n tiene el formato `user.Funcion()`. 
Si modificamos esa petici칩n y establecemos `blog-post-author-display=user.setAvatar('/home/carlos/User.php', 'image/jpg')` y la enviamos, al abrir la foto en una nueva pesta침a podemos ver el **c칩digo fuente** del archivo.

Con `curl` podemos traer el archivo completo a consola:
```bash
curl -s -X GET 'https://0acb00a3043125f580aac72f00ba0096.web-security-academy.net/avatar?avatar=wiener'
```

En su interior, observamos la siguiente funci칩n:
```php
public function gdprDelete() {
    $this->rm(readlink($this->avatarLink));
    $this->rm($this->avatarLink);
    $this->delete();
}
```

Esta funci칩n elimina el avatar que est칠 en uso actualmente.

Con esta informaci칩n ya es posible resolver el laboratorio. Lo que debemos hacer es:

- Cargar como avatar la clave id_rsa que queremos eliminar.
- Llamar a la funci칩n gdprDelete() para que el servidor la borre.

Primera petici칩n:
```bash
blog-post-author-display=user.setAvatar('/home/carlos/.ssh/id_rsa', 'image/jpg')&csrf=j1skDWV8Vi03uTHAiRFk0JqZUCMGwJMJ
```

Segunda petici칩n:
```bash
blog-post-author-display=user.gdprDelete()&csrf=j1skDWV8Vi03uTHAiRFk0JqZUCMGwJMJ
```

Y con todo esto, somos capaces de resolver el laboratorio.